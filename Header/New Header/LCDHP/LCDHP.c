/*
* LCD_HP.c
*
* Created: 4/10/2018 8:50:59 PM
*  Author: Van_BasTai
*/

#include "../include.h"
#include <avr/pgmspace.h>
#include "LCDHP.h"

// font 5x8
const unsigned char  font[][6] PROGMEM ={	//Font 5x7
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 20
	,{0x00, 0x00, 0x00, 0x5f, 0x00, 0x00} // 21 !
	,{0x00, 0x00, 0x07, 0x00, 0x07, 0x00} // 22 "
	,{0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14} // 23 #
	,{0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12} // 24 $
	,{0x00, 0x23, 0x13, 0x08, 0x64, 0x62} // 25 %
	,{0x00, 0x36, 0x49, 0x55, 0x22, 0x50} // 26 &
	,{0x00, 0x00, 0x05, 0x03, 0x00, 0x00} // 27 '
	,{0x00, 0x00, 0x1c, 0x22, 0x41, 0x00} // 28 (
	,{0x00, 0x00, 0x41, 0x22, 0x1c, 0x00} // 29 )
	,{0x00, 0x14, 0x08, 0x3e, 0x08, 0x14} // 2a *
	,{0x00, 0x08, 0x08, 0x3e, 0x08, 0x08} // 2b +
	,{0x00, 0x00, 0x50, 0x30, 0x00, 0x00} // 2c ,
	,{0x00, 0x08, 0x08, 0x08, 0x08, 0x08} // 2d -
	,{0x00, 0x00, 0x60, 0x60, 0x00, 0x00} // 2e .
	,{0x00, 0x20, 0x10, 0x08, 0x04, 0x02} // 2f /
	,{0x00, 0x3e, 0x51, 0x49, 0x45, 0x3e} // 30 0
	,{0x00, 0x00, 0x42, 0x7f, 0x40, 0x00} // 31 1
	,{0x00, 0x42, 0x61, 0x51, 0x49, 0x46} // 32 2
	,{0x00, 0x21, 0x41, 0x45, 0x4b, 0x31} // 33 3
	,{0x00, 0x18, 0x14, 0x12, 0x7f, 0x10} // 34 4
	,{0x00, 0x27, 0x45, 0x45, 0x45, 0x39} // 35 5
	,{0x00, 0x3c, 0x4a, 0x49, 0x49, 0x30} // 36 6
	,{0x00, 0x01, 0x71, 0x09, 0x05, 0x03} // 37 7
	,{0x00, 0x36, 0x49, 0x49, 0x49, 0x36} // 38 8
	,{0x00, 0x06, 0x49, 0x49, 0x29, 0x1e} // 39 9
	,{0x00, 0x00, 0x36, 0x36, 0x00, 0x00} // 3a :
	,{0x00, 0x00, 0x56, 0x36, 0x00, 0x00} // 3b ;
	,{0x00, 0x08, 0x14, 0x22, 0x41, 0x00} // 3c <
	,{0x00, 0x14, 0x14, 0x14, 0x14, 0x14} // 3d =
	,{0x00, 0x00, 0x41, 0x22, 0x14, 0x08} // 3e >
	,{0x00, 0x02, 0x01, 0x51, 0x09, 0x06} // 3f ?
	,{0x00, 0x32, 0x49, 0x79, 0x41, 0x3e} // 40 @
	,{0x00, 0x7e, 0x11, 0x11, 0x11, 0x7e} // 41 A
	,{0x00, 0x7f, 0x49, 0x49, 0x49, 0x36} // 42 B
	,{0x00, 0x3e, 0x41, 0x41, 0x41, 0x22} // 43 C
	,{0x00, 0x7f, 0x41, 0x41, 0x22, 0x1c} // 44 D
	,{0x00, 0x7f, 0x49, 0x49, 0x49, 0x41} // 45 E
	,{0x00, 0x7f, 0x09, 0x09, 0x09, 0x01} // 46 F
	,{0x00, 0x3e, 0x41, 0x49, 0x49, 0x7a} // 47 G
	,{0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f} // 48 H
	,{0x00, 0x00, 0x41, 0x7f, 0x41, 0x00} // 49 I
	,{0x00, 0x20, 0x40, 0x41, 0x3f, 0x01} // 4a J
	,{0x00, 0x7f, 0x08, 0x14, 0x22, 0x41} // 4b K
	,{0x00, 0x7f, 0x40, 0x40, 0x40, 0x40} // 4c L
	,{0x00, 0x7f, 0x02, 0x0c, 0x02, 0x7f} // 4d M
	,{0x00, 0x7f, 0x04, 0x08, 0x10, 0x7f} // 4e N
	,{0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e} // 4f O
	,{0x00, 0x7f, 0x09, 0x09, 0x09, 0x06} // 50 P
	,{0x00, 0x3e, 0x41, 0x51, 0x21, 0x5e} // 51 Q
	,{0x00, 0x7f, 0x09, 0x19, 0x29, 0x46} // 52 R
	,{0x00, 0x46, 0x49, 0x49, 0x49, 0x31} // 53 S
	,{0x00, 0x01, 0x01, 0x7f, 0x01, 0x01} // 54 T
	,{0x00, 0x3f, 0x40, 0x40, 0x40, 0x3f} // 55 U
	,{0x00, 0x1f, 0x20, 0x40, 0x20, 0x1f} // 56 V
	,{0x00, 0x3f, 0x40, 0x38, 0x40, 0x3f} // 57 W
	,{0x00, 0x63, 0x14, 0x08, 0x14, 0x63} // 58 X
	,{0x00, 0x07, 0x08, 0x70, 0x08, 0x07} // 59 Y
	,{0x00, 0x61, 0x51, 0x49, 0x45, 0x43} // 5a Z
	,{0x00, 0x00, 0x7f, 0x41, 0x41, 0x00} // 5b [
	,{0x00, 0x02, 0x04, 0x08, 0x10, 0x20} // 5c ¥
	,{0x00, 0x00, 0x41, 0x41, 0x7f, 0x00} // 5d ]
	,{0x00, 0x04, 0x02, 0x01, 0x02, 0x04} // 5e ^
	,{0x00, 0x40, 0x40, 0x40, 0x40, 0x40} // 5f _
	,{0x00, 0x00, 0x01, 0x02, 0x04, 0x00} // 60 `
	,{0x00, 0x20, 0x54, 0x54, 0x54, 0x78} // 61 a
	,{0x00, 0x7f, 0x48, 0x44, 0x44, 0x38} // 62 b
	,{0x00, 0x38, 0x44, 0x44, 0x44, 0x20} // 63 c
	,{0x00, 0x38, 0x44, 0x44, 0x48, 0x7f} // 64 d
	,{0x00, 0x38, 0x54, 0x54, 0x54, 0x18} // 65 e
	,{0x00, 0x08, 0x7e, 0x09, 0x01, 0x02} // 66 f
	,{0x00, 0x0c, 0x52, 0x52, 0x52, 0x3e} // 67 g
	,{0x00, 0x7f, 0x08, 0x04, 0x04, 0x78} // 68 h
	,{0x00, 0x00, 0x44, 0x7d, 0x40, 0x00} // 69 i
	,{0x00, 0x20, 0x40, 0x44, 0x3d, 0x00} // 6a j
	,{0x00, 0x7f, 0x10, 0x28, 0x44, 0x00} // 6b k
	,{0x00, 0x00, 0x41, 0x7f, 0x40, 0x00} // 6c l
	,{0x00, 0x7c, 0x04, 0x18, 0x04, 0x78} // 6d m
	,{0x00, 0x7c, 0x08, 0x04, 0x04, 0x78} // 6e n
	,{0x00, 0x38, 0x44, 0x44, 0x44, 0x38} // 6f o
	,{0x00, 0x7c, 0x14, 0x14, 0x14, 0x08} // 70 p
	,{0x00, 0x08, 0x14, 0x14, 0x18, 0x7c} // 71 q
	,{0x00, 0x7c, 0x08, 0x04, 0x04, 0x08} // 72 r
	,{0x00, 0x48, 0x54, 0x54, 0x54, 0x20} // 73 s
	,{0x00, 0x04, 0x3f, 0x44, 0x40, 0x20} // 74 t
	,{0x00, 0x3c, 0x40, 0x40, 0x20, 0x7c} // 75 u
	,{0x00, 0x1c, 0x20, 0x40, 0x20, 0x1c} // 76 v
	,{0x00, 0x3c, 0x40, 0x30, 0x40, 0x3c} // 77 w
	,{0x00, 0x44, 0x28, 0x10, 0x28, 0x44} // 78 x
	,{0x00, 0x0c, 0x50, 0x50, 0x50, 0x3c} // 79 y
	,{0x00, 0x44, 0x64, 0x54, 0x4c, 0x44} // 7a z
	,{0x00, 0x00, 0x08, 0x36, 0x41, 0x00} // 7b
	,{0x00, 0x00, 0x00, 0x7f, 0x00, 0x00} // 7c |
	,{0x00, 0x00, 0x41, 0x36, 0x08, 0x00} // 7d
	,{0x00, 0x10, 0x08, 0x08, 0x10, 0x08} // 7e ->
	,{0x00, 0x78, 0x46, 0x41, 0x46, 0x78} // 7f <-
};

void LCDHP_writeData(uint8_t byte)
{
	clrb(LCDHP_PORT,LCDHP_PIN_CS);
	setb(LCDHP_PORT,LCDHP_PIN_AO);
	
	for(uint8_t h = 0; h < 8; h++)
	{
		if(!(byte & 0x80)) clrb(LCDHP_PORT, LCDHP_PIN_SDA);
		else setb(LCDHP_PORT, LCDHP_PIN_SDA);
		
		clrb(LCDHP_PORT, LCDHP_PIN_CLK);
		setb(LCDHP_PORT, LCDHP_PIN_CLK);
		byte <<= 1;
	}
	daobit(LCDHP_PORT, LCDHP_PIN_AO);
	setb(LCDHP_PORT, LCDHP_PIN_CS);
}
void LCDHP_writeCommand(uint8_t byte)
{
	clrb(LCDHP_PORT,LCDHP_PIN_CS);
	clrb(LCDHP_PORT,LCDHP_PIN_AO);
	
	for(uint8_t h = 0; h < 8; h++)
	{
		if(!(byte & 0x80)) clrb(LCDHP_PORT, LCDHP_PIN_SDA);
		else setb(LCDHP_PORT, LCDHP_PIN_SDA);
		
		clrb(LCDHP_PORT, LCDHP_PIN_CLK);
		setb(LCDHP_PORT, LCDHP_PIN_CLK);
		byte <<= 1;
	}
	daobit(LCDHP_PORT, LCDHP_PIN_AO);
	setb(LCDHP_PORT, LCDHP_PIN_CS);
}
void LCDHP_config()
{
	LCDHP_DDR |= (1 << LCDHP_PIN_AO) | (1 << LCDHP_PIN_CS) | (1 << LCDHP_PIN_CLK) | (1 << LCDHP_PIN_SDA);
	LCDHP_PORT &= ~(1 << LCDHP_PIN_AO) & ~(1 << LCDHP_PIN_CS) & ~(1 << LCDHP_PIN_CLK) & ~(1 << LCDHP_PIN_SDA);
	
	//LCDHP_writeCommand(0xA0);// Display ON, 0xAE - OFF
	_delay_ms(10);
	
	LCDHP_writeCommand(0xE2);// Reset
	_delay_ms(100);// Delay 100ms
	LCDHP_writeCommand(0xAF);// Display ON, 0xAE - OFF
	_delay_ms(10);
	LCDHP_writeCommand(0x2F);// Power control
	_delay_ms(10);
	
	//LCDHP_writeCommand(0x26); //regulation ratio
	LCDHP_clear();// Clear screen
}
void LCDHP_goTo(uint8_t x, uint8_t y)
{
	y--;
	x--;
	y *= 6;// This line for text mode, comment this line if graphic mode
	LCDHP_writeCommand((y & 0x0f));
	LCDHP_writeCommand(((y >> 4) & 0x07) | 0x10);
	LCDHP_writeCommand((x & 0x0f) | 0xb0);
}
void LCDHP_clear()
{
	for(uint8_t u = 0; u < 8; u++)
	{
		LCDHP_goTo(u + 1, 1);
		for(uint8_t w = 0; w < 130; w++)
		{
			LCDHP_writeData(0);
		}
	}
	LCDHP_goTo(1, 1);
}
void LCDHP_putC(uint8_t dat)
{
	if((dat >= 0x20) && (dat <= 0x7f))
	{
		dat -= 32;
		for(uint8_t v = 0;v < 6; v++)
		LCDHP_writeData(pgm_read_byte(&font[dat][v]));
	}
}
void LCDHP_putC_R(uint8_t dat)
{
	if((dat >= 0x20) && (dat <= 0x7f))
	{
		dat -= 32;
		for(uint8_t v = 0;v < 6; v++)
		LCDHP_writeData(~pgm_read_byte(&font[dat][v]));
	}
}
void LCDHP_print(char *str)
{
	while(*str)
	LCDHP_putC(*str++);
}
void LCDHP_printNum(long num, uint8_t base)
{
	char dis[20];
	if (base == DEC)	sprintf(dis, "%li", num);
	else if (base == HEX)	sprintf(dis, "0x%lx", num);
	else if (base == BIN)	sprintf(dis, "can't print binary number");
	LCDHP_print(dis);
}
void LCDHP_printFloat(double num, uint8_t digits)
{
	if (isnan(num)) return LCDHP_print("nan");
	if (isinf(num)) return LCDHP_print("inf");
	if (num > 4294967040.0) return LCDHP_print ("ovf");  // constant determined empirically
	if (num <-4294967040.0) return LCDHP_print ("ovf");  // constant determined empirically
	
	// Handle negative numbers
	if (num < 0.0)
	{
		LCDHP_putC('-');
		num = -num;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i)
	rounding /= 10.0;
	
	num += rounding;

	// Extract the integer part of the num and print it
	unsigned long int_part = (unsigned long)num;
	double remainder = num - (double)int_part;
	LCDHP_printNum(int_part, DEC);

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
		LCDHP_putC('.');
	}

	// Extract digits from the remainder one at a time
	while (digits-- > 0)
	{
		remainder *= 10.0;
		unsigned int toPrint = (unsigned int)(remainder);
		LCDHP_printNum(toPrint, DEC);
		remainder -= toPrint;
	}
}
void LCDHP_goToPixel(uint8_t x, uint8_t y)
{
	y--;
	x--;
	
	LCDHP_writeCommand((y & 0x0f));
	LCDHP_writeCommand(((y >> 4) & 0x07) | 0x10);
	LCDHP_writeCommand((x & 0x0f) | 0xb0);
}
void LCDHP_picture(int dat)
{
	//if((dat >= 0x20) && (dat <= 0x7f))
	//{
	//dat=dat+8;
	//for(int v=0;v<128;v++)
	//LCDHP_writeData(pgm_read_byte(&anh[dat][v]));
	//}
}
void LCDHP_space(uint8_t num)
{
	for (; num > 0; num--)
	{
		LCDHP_putC(32);
	}
}
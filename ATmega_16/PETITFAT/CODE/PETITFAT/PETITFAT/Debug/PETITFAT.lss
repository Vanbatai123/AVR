
PETITFAT.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c9a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010c  00800060  00000c9a  00000d2e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  0080016c  0080016c  00000e3a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e3a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000178  00000000  00000000  00000e6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001a10  00000000  00000000  00000fe2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003d9  00000000  00000000  000029f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000747  00000000  00000000  00002dcb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000560  00000000  00000000  00003514  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000007e4  00000000  00000000  00003a74  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001311  00000000  00000000  00004258  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000168  00000000  00000000  00005569  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e9       	ldi	r30, 0x9A	; 154
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ac 36       	cpi	r26, 0x6C	; 108
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	21 e0       	ldi	r18, 0x01	; 1
  78:	ac e6       	ldi	r26, 0x6C	; 108
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a4 37       	cpi	r26, 0x74	; 116
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 20 04 	call	0x840	; 0x840 <main>
  8a:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ms_delay>:

	while ( 0x00 != sdsc_command ( WRITE_SINGLE_BLOCK, block_address ) );
	sdsc -> spi_tx ( 0xfe );     
	for ( i=0; i < 512; i++ )    
  		sdsc -> spi_tx ( buf [ i ] );
	sdsc -> spi_tx ( 0xff );     
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	00 d0       	rcall	.+0      	; 0x98 <ms_delay+0x6>
	sdsc -> spi_tx ( 0xff );
  98:	00 d0       	rcall	.+0      	; 0x9a <ms_delay+0x8>
  9a:	cd b7       	in	r28, 0x3d	; 61
  9c:	de b7       	in	r29, 0x3e	; 62
  9e:	0e 94 8e 04 	call	0x91c	; 0x91c <__fixsfsi>
  a2:	7a 83       	std	Y+2, r23	; 0x02
  a4:	69 83       	std	Y+1, r22	; 0x01
  a6:	89 81       	ldd	r24, Y+1	; 0x01
  a8:	9a 81       	ldd	r25, Y+2	; 0x02

	r1 = sdsc -> spi_rx ();
  aa:	89 2b       	or	r24, r25
  ac:	d1 f0       	breq	.+52     	; 0xe2 <ms_delay+0x50>
  ae:	1c 82       	std	Y+4, r1	; 0x04
  b0:	1b 82       	std	Y+3, r1	; 0x03
  b2:	8b 81       	ldd	r24, Y+3	; 0x03
  b4:	9c 81       	ldd	r25, Y+4	; 0x04
  b6:	80 39       	cpi	r24, 0x90	; 144
  b8:	91 40       	sbci	r25, 0x01	; 1
  ba:	54 f4       	brge	.+20     	; 0xd0 <ms_delay+0x3e>

	if( ( r1 & 0x1f) != 0x05 )  	   //r1 = 0bXXX0AAA1 ; AAA='010' - data accepted
  bc:	8b 81       	ldd	r24, Y+3	; 0x03
  be:	9c 81       	ldd	r25, Y+4	; 0x04
  c0:	01 96       	adiw	r24, 0x01	; 1
	{                                  //AAA='101'-data rejected due to CRC error
  		sdsc -> sdsc_deassert ();;            	   //AAA='110'-data rejected due to write error
  c2:	9c 83       	std	Y+4, r25	; 0x04
  c4:	8b 83       	std	Y+3, r24	; 0x03
  c6:	8b 81       	ldd	r24, Y+3	; 0x03
  c8:	9c 81       	ldd	r25, Y+4	; 0x04
  ca:	80 39       	cpi	r24, 0x90	; 144
  cc:	91 40       	sbci	r25, 0x01	; 1
  ce:	b4 f3       	brlt	.-20     	; 0xbc <ms_delay+0x2a>
  d0:	89 81       	ldd	r24, Y+1	; 0x01
  		return r1;
  d2:	9a 81       	ldd	r25, Y+2	; 0x02
  d4:	01 97       	sbiw	r24, 0x01	; 1
	}else;

	while ( ! sdsc -> spi_rx () ); 				//wait till writing completed
  d6:	9a 83       	std	Y+2, r25	; 0x02
  d8:	89 83       	std	Y+1, r24	; 0x01
  da:	89 81       	ldd	r24, Y+1	; 0x01
  dc:	9a 81       	ldd	r25, Y+2	; 0x02
  de:	89 2b       	or	r24, r25
  e0:	31 f7       	brne	.-52     	; 0xae <ms_delay+0x1c>
  e2:	0f 90       	pop	r0
  e4:	0f 90       	pop	r0
  e6:	0f 90       	pop	r0
  e8:	0f 90       	pop	r0

	sdsc -> sdsc_deassert ();;
  ea:	df 91       	pop	r29
  ec:	cf 91       	pop	r28
  ee:	08 95       	ret

000000f0 <spi_init>:
  f0:	8f eb       	ldi	r24, 0xBF	; 191
  f2:	87 bb       	out	0x17, r24	; 23
  f4:	82 e5       	ldi	r24, 0x52	; 82
  f6:	8d b9       	out	0x0d, r24	; 13
  f8:	1e b8       	out	0x0e, r1	; 14

	sdsc -> spi_tx ( 0xff );   					//confirm not in busy state
  fa:	60 e0       	ldi	r22, 0x00	; 0
  fc:	70 e0       	ldi	r23, 0x00	; 0
  fe:	80 e2       	ldi	r24, 0x20	; 32
 100:	91 e4       	ldi	r25, 0x41	; 65
 102:	0e 94 49 00 	call	0x92	; 0x92 <ms_delay>
 106:	08 95       	ret

00000108 <Write2Nib>:
 108:	2b b3       	in	r18, 0x1b	; 27
 10a:	2f 70       	andi	r18, 0x0F	; 15

	sdsc -> sdsc_assert ();
 10c:	98 2f       	mov	r25, r24
 10e:	90 7f       	andi	r25, 0xF0	; 240
 110:	92 2b       	or	r25, r18
 112:	9b bb       	out	0x1b, r25	; 27
 114:	db 9a       	sbi	0x1b, 3	; 27
 116:	db 98       	cbi	0x1b, 3	; 27
 118:	30 e1       	ldi	r19, 0x10	; 16
 11a:	83 9f       	mul	r24, r19
	while ( ! sdsc -> spi_rx () );
 11c:	c0 01       	movw	r24, r0
 11e:	11 24       	eor	r1, r1
 120:	82 2b       	or	r24, r18
 122:	8b bb       	out	0x1b, r24	; 27
 124:	db 9a       	sbi	0x1b, 3	; 27
 126:	db 98       	cbi	0x1b, 3	; 27
 128:	08 95       	ret

0000012a <init_LCD>:
 12a:	8f ef       	ldi	r24, 0xFF	; 255
 12c:	8a bb       	out	0x1a, r24	; 26
 12e:	d4 9a       	sbi	0x1a, 4	; 26
	sdsc -> sdsc_deassert ();;
 130:	d5 9a       	sbi	0x1a, 5	; 26
 132:	d6 9a       	sbi	0x1a, 6	; 26
 134:	d7 9a       	sbi	0x1a, 7	; 26
 136:	da 98       	cbi	0x1b, 2	; 27
 138:	db 98       	cbi	0x1b, 3	; 27
 13a:	db 9a       	sbi	0x1b, 3	; 27
 13c:	dd 9a       	sbi	0x1b, 5	; 27
 13e:	db 98       	cbi	0x1b, 3	; 27

	return 0;
}
 140:	8f ec       	ldi	r24, 0xCF	; 207
 142:	97 e0       	ldi	r25, 0x07	; 7
 144:	01 97       	sbiw	r24, 0x01	; 1
 146:	f1 f7       	brne	.-4      	; 0x144 <init_LCD+0x1a>
 148:	00 c0       	rjmp	.+0      	; 0x14a <init_LCD+0x20>
 14a:	00 00       	nop
 14c:	88 e2       	ldi	r24, 0x28	; 40
 14e:	0e 94 84 00 	call	0x108	; 0x108 <Write2Nib>
 152:	8f ec       	ldi	r24, 0xCF	; 207
 154:	97 e0       	ldi	r25, 0x07	; 7
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 156:	01 97       	sbiw	r24, 0x01	; 1
 158:	f1 f7       	brne	.-4      	; 0x156 <init_LCD+0x2c>
 15a:	00 c0       	rjmp	.+0      	; 0x15c <init_LCD+0x32>
 15c:	00 00       	nop
	wait_LCD();
	Write2Nib(0x28);//4 bit mode, 2 line, 5x8 font
	wait_LCD();
	
	//Display control-------------------------------------------------------------------------
	cbi(CTRL,RS); // the following data is COMMAND
 15e:	da 98       	cbi	0x1b, 2	; 27
	
	Write2Nib(0x0C);
 160:	8c e0       	ldi	r24, 0x0C	; 12
 162:	0e 94 84 00 	call	0x108	; 0x108 <Write2Nib>
 166:	8f ec       	ldi	r24, 0xCF	; 207
 168:	97 e0       	ldi	r25, 0x07	; 7
 16a:	01 97       	sbiw	r24, 0x01	; 1
 16c:	f1 f7       	brne	.-4      	; 0x16a <init_LCD+0x40>
 16e:	00 c0       	rjmp	.+0      	; 0x170 <init_LCD+0x46>
 170:	00 00       	nop
	//Write2Nib(0x0E);-------------co con tro
	wait_LCD();
	
	//Entry mode set------------------------------------------------------------------------
	cbi(CTRL,RS); // the following data is COMMAND
 172:	da 98       	cbi	0x1b, 2	; 27
	
	Write2Nib(0x06);
 174:	86 e0       	ldi	r24, 0x06	; 6
 176:	0e 94 84 00 	call	0x108	; 0x108 <Write2Nib>
 17a:	8f ec       	ldi	r24, 0xCF	; 207
 17c:	97 e0       	ldi	r25, 0x07	; 7
 17e:	01 97       	sbiw	r24, 0x01	; 1
 180:	f1 f7       	brne	.-4      	; 0x17e <init_LCD+0x54>
 182:	00 c0       	rjmp	.+0      	; 0x184 <init_LCD+0x5a>
 184:	00 00       	nop
 186:	08 95       	ret

00000188 <move_LCD>:
}
void move_LCD(uint8_t y,uint8_t x)
{
	uint8_t Ad;
	Ad=64*(y-1)+(x-1)+0x80; // tính mã l?nh
	cbi(CTRL,RS); // the following data is COMMAND
 188:	da 98       	cbi	0x1b, 2	; 27
	
}
void move_LCD(uint8_t y,uint8_t x)
{
	uint8_t Ad;
	Ad=64*(y-1)+(x-1)+0x80; // tính mã l?nh
 18a:	90 e4       	ldi	r25, 0x40	; 64
 18c:	89 9f       	mul	r24, r25
 18e:	60 0d       	add	r22, r0
 190:	11 24       	eor	r1, r1
 192:	86 2f       	mov	r24, r22
	cbi(CTRL,RS); // the following data is COMMAND
	
	Write2Nib(Ad);
 194:	81 5c       	subi	r24, 0xC1	; 193
 196:	0e 94 84 00 	call	0x108	; 0x108 <Write2Nib>
 19a:	8f ec       	ldi	r24, 0xCF	; 207
 19c:	97 e0       	ldi	r25, 0x07	; 7
 19e:	01 97       	sbiw	r24, 0x01	; 1
 1a0:	f1 f7       	brne	.-4      	; 0x19e <move_LCD+0x16>
 1a2:	00 c0       	rjmp	.+0      	; 0x1a4 <move_LCD+0x1c>
 1a4:	00 00       	nop
 1a6:	08 95       	ret

000001a8 <putChar_LCD>:
}


void putChar_LCD(uint8_t chr)
{ //hi?n th? 1 ký t? chr lên LCD
	sbi(CTRL,RS); //this is a normal DATA
 1a8:	da 9a       	sbi	0x1b, 2	; 27
	
	Write2Nib(chr);
 1aa:	0e 94 84 00 	call	0x108	; 0x108 <Write2Nib>
 1ae:	8f ec       	ldi	r24, 0xCF	; 207
 1b0:	97 e0       	ldi	r25, 0x07	; 7
 1b2:	01 97       	sbiw	r24, 0x01	; 1
 1b4:	f1 f7       	brne	.-4      	; 0x1b2 <putChar_LCD+0xa>
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <putChar_LCD+0x10>
 1b8:	00 00       	nop
 1ba:	08 95       	ret

000001bc <print_LCD>:
	wait_LCD();
	
}
void print_LCD(char* str)//******__HIEN THI CHUOI KI TU__*********************
{
 1bc:	cf 93       	push	r28
 1be:	df 93       	push	r29
 1c0:	ec 01       	movw	r28, r24
	int i;
	for (i=0; str[i]!=0; i++) 
 1c2:	88 81       	ld	r24, Y
 1c4:	88 23       	and	r24, r24
 1c6:	31 f0       	breq	.+12     	; 0x1d4 <print_LCD+0x18>
 1c8:	21 96       	adiw	r28, 0x01	; 1
	putChar_LCD(str[i]);
 1ca:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <putChar_LCD>
	
}
void print_LCD(char* str)//******__HIEN THI CHUOI KI TU__*********************
{
	int i;
	for (i=0; str[i]!=0; i++) 
 1ce:	89 91       	ld	r24, Y+
 1d0:	81 11       	cpse	r24, r1
 1d2:	fb cf       	rjmp	.-10     	; 0x1ca <print_LCD+0xe>
	putChar_LCD(str[i]);
}
 1d4:	df 91       	pop	r29
 1d6:	cf 91       	pop	r28
 1d8:	08 95       	ret

000001da <clr_LCD>:
void clr_LCD()
{ //xóa toàn b? LCD
	//cbi(CTRL,RS); //RS=0 mean the following data is COMMAND (not normal DATA)
	//Write2Nib(0x01);
	//wait_LCD();
	move_LCD(1,1);
 1da:	61 e0       	ldi	r22, 0x01	; 1
 1dc:	81 e0       	ldi	r24, 0x01	; 1
 1de:	0e 94 c4 00 	call	0x188	; 0x188 <move_LCD>
	print_LCD("                ");
 1e2:	89 e6       	ldi	r24, 0x69	; 105
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	0e 94 de 00 	call	0x1bc	; 0x1bc <print_LCD>
	move_LCD(2,1);
 1ea:	61 e0       	ldi	r22, 0x01	; 1
 1ec:	82 e0       	ldi	r24, 0x02	; 2
 1ee:	0e 94 c4 00 	call	0x188	; 0x188 <move_LCD>
	print_LCD("                ");
 1f2:	89 e6       	ldi	r24, 0x69	; 105
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	0e 94 de 00 	call	0x1bc	; 0x1bc <print_LCD>
	move_LCD(1,1);
 1fa:	61 e0       	ldi	r22, 0x01	; 1
 1fc:	81 e0       	ldi	r24, 0x01	; 1
 1fe:	0e 94 c4 00 	call	0x188	; 0x188 <move_LCD>
 202:	08 95       	ret

00000204 <sdsc_command>:


#include "C:\Users\Administrator\Downloads\Compressed\CODE\CODE\sdsc.h"

unsigned char sdsc_command ( unsigned char cmd, unsigned long arg )
{
 204:	ff 92       	push	r15
 206:	0f 93       	push	r16
 208:	1f 93       	push	r17
 20a:	cf 93       	push	r28
 20c:	df 93       	push	r29
 20e:	c8 2f       	mov	r28, r24
 210:	d4 2f       	mov	r29, r20
 212:	15 2f       	mov	r17, r21
 214:	06 2f       	mov	r16, r22
 216:	f7 2e       	mov	r15, r23
	unsigned char r1;

	sdsc -> spi_tx ( cmd | 0x40 ); 
 218:	e0 91 6e 01 	lds	r30, 0x016E
 21c:	f0 91 6f 01 	lds	r31, 0x016F
 220:	04 80       	ldd	r0, Z+4	; 0x04
 222:	f5 81       	ldd	r31, Z+5	; 0x05
 224:	e0 2d       	mov	r30, r0
 226:	80 64       	ori	r24, 0x40	; 64
 228:	09 95       	icall
	sdsc -> spi_tx ( arg >> 24 );
 22a:	e0 91 6e 01 	lds	r30, 0x016E
 22e:	f0 91 6f 01 	lds	r31, 0x016F
 232:	04 80       	ldd	r0, Z+4	; 0x04
 234:	f5 81       	ldd	r31, Z+5	; 0x05
 236:	e0 2d       	mov	r30, r0
 238:	8f 2d       	mov	r24, r15
 23a:	09 95       	icall
	sdsc -> spi_tx ( arg >> 16 );
 23c:	e0 91 6e 01 	lds	r30, 0x016E
 240:	f0 91 6f 01 	lds	r31, 0x016F
 244:	04 80       	ldd	r0, Z+4	; 0x04
 246:	f5 81       	ldd	r31, Z+5	; 0x05
 248:	e0 2d       	mov	r30, r0
 24a:	80 2f       	mov	r24, r16
 24c:	09 95       	icall
	sdsc -> spi_tx ( arg >> 8 );
 24e:	e0 91 6e 01 	lds	r30, 0x016E
 252:	f0 91 6f 01 	lds	r31, 0x016F
 256:	04 80       	ldd	r0, Z+4	; 0x04
 258:	f5 81       	ldd	r31, Z+5	; 0x05
 25a:	e0 2d       	mov	r30, r0
 25c:	81 2f       	mov	r24, r17
 25e:	09 95       	icall
	sdsc -> spi_tx ( arg );
 260:	e0 91 6e 01 	lds	r30, 0x016E
 264:	f0 91 6f 01 	lds	r31, 0x016F
 268:	04 80       	ldd	r0, Z+4	; 0x04
 26a:	f5 81       	ldd	r31, Z+5	; 0x05
 26c:	e0 2d       	mov	r30, r0
 26e:	8d 2f       	mov	r24, r29
 270:	09 95       	icall

	if ( cmd == SEND_IF_COND )
 272:	c8 30       	cpi	r28, 0x08	; 8
 274:	51 f4       	brne	.+20     	; 0x28a <sdsc_command+0x86>
	  sdsc -> spi_tx ( 0x87 );     
 276:	e0 91 6e 01 	lds	r30, 0x016E
 27a:	f0 91 6f 01 	lds	r31, 0x016F
 27e:	04 80       	ldd	r0, Z+4	; 0x04
 280:	f5 81       	ldd	r31, Z+5	; 0x05
 282:	e0 2d       	mov	r30, r0
 284:	87 e8       	ldi	r24, 0x87	; 135
 286:	09 95       	icall
 288:	09 c0       	rjmp	.+18     	; 0x29c <sdsc_command+0x98>
	else 
	  sdsc -> spi_tx ( 0x95 ); 
 28a:	e0 91 6e 01 	lds	r30, 0x016E
 28e:	f0 91 6f 01 	lds	r31, 0x016F
 292:	04 80       	ldd	r0, Z+4	; 0x04
 294:	f5 81       	ldd	r31, Z+5	; 0x05
 296:	e0 2d       	mov	r30, r0
 298:	85 e9       	ldi	r24, 0x95	; 149
 29a:	09 95       	icall

	while ( ( r1 = sdsc -> spi_rx () ) == 0xff ); //wait response
 29c:	e0 91 6e 01 	lds	r30, 0x016E
 2a0:	f0 91 6f 01 	lds	r31, 0x016F
 2a4:	06 80       	ldd	r0, Z+6	; 0x06
 2a6:	f7 81       	ldd	r31, Z+7	; 0x07
 2a8:	e0 2d       	mov	r30, r0
 2aa:	09 95       	icall
 2ac:	8f 3f       	cpi	r24, 0xFF	; 255
 2ae:	b1 f3       	breq	.-20     	; 0x29c <sdsc_command+0x98>

	return r1; 
}
 2b0:	df 91       	pop	r29
 2b2:	cf 91       	pop	r28
 2b4:	1f 91       	pop	r17
 2b6:	0f 91       	pop	r16
 2b8:	ff 90       	pop	r15
 2ba:	08 95       	ret

000002bc <sdsc_init>:

void sdsc_init ( void )
{
	spi_init ();
 2bc:	0e 94 78 00 	call	0xf0	; 0xf0 <spi_init>

	//sdsc -> sdsc_assert ();
	while ( 0x01 != sdsc_command ( GO_IDLE_STATE, 0 ) );
 2c0:	40 e0       	ldi	r20, 0x00	; 0
 2c2:	50 e0       	ldi	r21, 0x00	; 0
 2c4:	ba 01       	movw	r22, r20
 2c6:	80 e0       	ldi	r24, 0x00	; 0
 2c8:	0e 94 02 01 	call	0x204	; 0x204 <sdsc_command>
 2cc:	81 30       	cpi	r24, 0x01	; 1
 2ce:	c1 f7       	brne	.-16     	; 0x2c0 <sdsc_init+0x4>
	//while ( sdsc_command ( APP_CMD, 0 ) && sdsc_command ( SD_SEND_OP_COND, 0x40000000 ) );
	//while ( 0x00 != sdsc_command ( READ_OCR, 0 ) );
	//sdsc -> sdsc_deassert ();
	
	//sdsc -> spi_init_2x ();
}
 2d0:	08 95       	ret

000002d2 <read_sector>:

#include "C:\Users\Administrator\Downloads\Compressed\CODE\CODE\fat32.h"
#include <stdlib.h>

void * read_sector ( unsigned long sector_address, void *buf )
{
 2d2:	cf 93       	push	r28
 2d4:	df 93       	push	r29
 2d6:	ea 01       	movw	r28, r20
	fat -> read_single_block ( sector_address, ( unsigned char * ) buf );
 2d8:	e0 91 6c 01 	lds	r30, 0x016C
 2dc:	f0 91 6d 01 	lds	r31, 0x016D
 2e0:	02 88       	ldd	r0, Z+18	; 0x12
 2e2:	f3 89       	ldd	r31, Z+19	; 0x13
 2e4:	e0 2d       	mov	r30, r0
 2e6:	09 95       	icall
	return buf;
}
 2e8:	ce 01       	movw	r24, r28
 2ea:	df 91       	pop	r29
 2ec:	cf 91       	pop	r28
 2ee:	08 95       	ret

000002f0 <first_sector_of_cluster>:
	return 0;

}

unsigned long first_sector_of_cluster ( unsigned long cluster_number )
{
 2f0:	cf 92       	push	r12
 2f2:	df 92       	push	r13
 2f4:	ef 92       	push	r14
 2f6:	ff 92       	push	r15
  return ( ( ( cluster_number - 2 ) * fat -> sector_per_cluster ) + fat -> first_data_sector );
 2f8:	e0 91 6c 01 	lds	r30, 0x016C
 2fc:	f0 91 6d 01 	lds	r31, 0x016D
 300:	a6 85       	ldd	r26, Z+14	; 0x0e
 302:	b7 85       	ldd	r27, Z+15	; 0x0f
 304:	c4 80       	ldd	r12, Z+4	; 0x04
 306:	d5 80       	ldd	r13, Z+5	; 0x05
 308:	e6 80       	ldd	r14, Z+6	; 0x06
 30a:	f7 80       	ldd	r15, Z+7	; 0x07
 30c:	9b 01       	movw	r18, r22
 30e:	ac 01       	movw	r20, r24
 310:	22 50       	subi	r18, 0x02	; 2
 312:	31 09       	sbc	r19, r1
 314:	41 09       	sbc	r20, r1
 316:	51 09       	sbc	r21, r1
 318:	0e 94 0a 05 	call	0xa14	; 0xa14 <__muluhisi3>
 31c:	6c 0d       	add	r22, r12
 31e:	7d 1d       	adc	r23, r13
 320:	8e 1d       	adc	r24, r14
 322:	9f 1d       	adc	r25, r15
}
 324:	ff 90       	pop	r15
 326:	ef 90       	pop	r14
 328:	df 90       	pop	r13
 32a:	cf 90       	pop	r12
 32c:	08 95       	ret

0000032e <next_cluster_number>:
	}
	return 0;
}

unsigned long next_cluster_number ( unsigned long current_cluster_number )
{
 32e:	8f 92       	push	r8
 330:	9f 92       	push	r9
 332:	af 92       	push	r10
 334:	bf 92       	push	r11
 336:	cf 92       	push	r12
 338:	df 92       	push	r13
 33a:	ef 92       	push	r14
 33c:	ff 92       	push	r15
 33e:	0f 93       	push	r16
 340:	1f 93       	push	r17
 342:	cf 93       	push	r28
 344:	df 93       	push	r29
	unsigned int offset_of_current_cluster;
	unsigned char *sector_data;
	unsigned long *fat_sector_data;
	unsigned long next_cluster;

	fat_sector_for_current_cluster = fat -> first_used_sector + fat -> reserved_sector_count 
 346:	c0 91 6c 01 	lds	r28, 0x016C
 34a:	d0 91 6d 01 	lds	r29, 0x016D
 34e:	48 89       	ldd	r20, Y+16	; 0x10
 350:	59 89       	ldd	r21, Y+17	; 0x11
									 + ( ( current_cluster_number * 4 ) / fat -> bytes_per_sector );
 352:	6b 01       	movw	r12, r22
 354:	7c 01       	movw	r14, r24
 356:	cc 0c       	add	r12, r12
 358:	dd 1c       	adc	r13, r13
 35a:	ee 1c       	adc	r14, r14
 35c:	ff 1c       	adc	r15, r15
 35e:	cc 0c       	add	r12, r12
 360:	dd 1c       	adc	r13, r13
 362:	ee 1c       	adc	r14, r14
 364:	ff 1c       	adc	r15, r15
 366:	2c 85       	ldd	r18, Y+12	; 0x0c
 368:	3d 85       	ldd	r19, Y+13	; 0x0d
	unsigned int offset_of_current_cluster;
	unsigned char *sector_data;
	unsigned long *fat_sector_data;
	unsigned long next_cluster;

	fat_sector_for_current_cluster = fat -> first_used_sector + fat -> reserved_sector_count 
 36a:	88 80       	ld	r8, Y
 36c:	99 80       	ldd	r9, Y+1	; 0x01
 36e:	aa 80       	ldd	r10, Y+2	; 0x02
 370:	bb 80       	ldd	r11, Y+3	; 0x03
 372:	84 0e       	add	r8, r20
 374:	95 1e       	adc	r9, r21
 376:	a1 1c       	adc	r10, r1
 378:	b1 1c       	adc	r11, r1
									 + ( ( current_cluster_number * 4 ) / fat -> bytes_per_sector );
 37a:	40 e0       	ldi	r20, 0x00	; 0
 37c:	50 e0       	ldi	r21, 0x00	; 0
 37e:	c7 01       	movw	r24, r14
 380:	b6 01       	movw	r22, r12
 382:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <__udivmodsi4>
	unsigned int offset_of_current_cluster;
	unsigned char *sector_data;
	unsigned long *fat_sector_data;
	unsigned long next_cluster;

	fat_sector_for_current_cluster = fat -> first_used_sector + fat -> reserved_sector_count 
 386:	82 0e       	add	r8, r18
 388:	93 1e       	adc	r9, r19
 38a:	a4 1e       	adc	r10, r20
 38c:	b5 1e       	adc	r11, r21
									 + ( ( current_cluster_number * 4 ) / fat -> bytes_per_sector );
	offset_of_current_cluster = ( unsigned int ) ( ( current_cluster_number * 4 ) % fat -> bytes_per_sector );
 38e:	0c 85       	ldd	r16, Y+12	; 0x0c
 390:	1d 85       	ldd	r17, Y+13	; 0x0d

	sector_data = ( unsigned char * ) read_sector ( 
 392:	8c 85       	ldd	r24, Y+12	; 0x0c
 394:	9d 85       	ldd	r25, Y+13	; 0x0d
 396:	0e 94 24 05 	call	0xa48	; 0xa48 <malloc>
 39a:	ac 01       	movw	r20, r24
 39c:	c5 01       	movw	r24, r10
 39e:	b4 01       	movw	r22, r8
 3a0:	0e 94 69 01 	call	0x2d2	; 0x2d2 <read_sector>
 3a4:	ec 01       	movw	r28, r24
	unsigned long *fat_sector_data;
	unsigned long next_cluster;

	fat_sector_for_current_cluster = fat -> first_used_sector + fat -> reserved_sector_count 
									 + ( ( current_cluster_number * 4 ) / fat -> bytes_per_sector );
	offset_of_current_cluster = ( unsigned int ) ( ( current_cluster_number * 4 ) % fat -> bytes_per_sector );
 3a6:	98 01       	movw	r18, r16
 3a8:	40 e0       	ldi	r20, 0x00	; 0
 3aa:	50 e0       	ldi	r21, 0x00	; 0
 3ac:	c7 01       	movw	r24, r14
 3ae:	b6 01       	movw	r22, r12
 3b0:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <__udivmodsi4>
														    fat_sector_for_current_cluster,
															malloc ( fat -> bytes_per_sector )
							    		   		   );	
	fat_sector_data = ( unsigned long * ) &sector_data [ offset_of_current_cluster ];

	next_cluster = ( ( *fat_sector_data ) & 0x0fffffff );
 3b4:	fe 01       	movw	r30, r28
 3b6:	e6 0f       	add	r30, r22
 3b8:	f7 1f       	adc	r31, r23
 3ba:	c0 80       	ld	r12, Z
 3bc:	d1 80       	ldd	r13, Z+1	; 0x01
 3be:	e2 80       	ldd	r14, Z+2	; 0x02
 3c0:	f3 80       	ldd	r15, Z+3	; 0x03
 3c2:	8f e0       	ldi	r24, 0x0F	; 15
 3c4:	f8 22       	and	r15, r24

	free ( sector_data );
 3c6:	ce 01       	movw	r24, r28
 3c8:	0e 94 bc 05 	call	0xb78	; 0xb78 <free>

	return next_cluster;

}
 3cc:	c7 01       	movw	r24, r14
 3ce:	b6 01       	movw	r22, r12
 3d0:	df 91       	pop	r29
 3d2:	cf 91       	pop	r28
 3d4:	1f 91       	pop	r17
 3d6:	0f 91       	pop	r16
 3d8:	ff 90       	pop	r15
 3da:	ef 90       	pop	r14
 3dc:	df 90       	pop	r13
 3de:	cf 90       	pop	r12
 3e0:	bf 90       	pop	r11
 3e2:	af 90       	pop	r10
 3e4:	9f 90       	pop	r9
 3e6:	8f 90       	pop	r8
 3e8:	08 95       	ret

000003ea <first_cluster_of_file>:
{
  return ( ( ( cluster_number - 2 ) * fat -> sector_per_cluster ) + fat -> first_data_sector );
}

unsigned long first_cluster_of_file ( char *f_name )
{
 3ea:	2f 92       	push	r2
 3ec:	3f 92       	push	r3
 3ee:	4f 92       	push	r4
 3f0:	5f 92       	push	r5
 3f2:	6f 92       	push	r6
 3f4:	7f 92       	push	r7
 3f6:	8f 92       	push	r8
 3f8:	9f 92       	push	r9
 3fa:	af 92       	push	r10
 3fc:	bf 92       	push	r11
 3fe:	cf 92       	push	r12
 400:	df 92       	push	r13
 402:	ef 92       	push	r14
 404:	ff 92       	push	r15
 406:	0f 93       	push	r16
 408:	1f 93       	push	r17
 40a:	cf 93       	push	r28
 40c:	df 93       	push	r29
 40e:	3c 01       	movw	r6, r24
	unsigned long cluster_number, sector_number;
	unsigned long first_cluster;
	int i, j;
	fs_dir *dir;

	cluster_number = fat -> root_cluster;
 410:	e0 91 6c 01 	lds	r30, 0x016C
 414:	f0 91 6d 01 	lds	r31, 0x016D
 418:	80 84       	ldd	r8, Z+8	; 0x08
 41a:	91 84       	ldd	r9, Z+9	; 0x09
 41c:	a2 84       	ldd	r10, Z+10	; 0x0a
 41e:	b3 84       	ldd	r11, Z+11	; 0x0b

	while ( cluster_number < 0x0ffffff6 )
 420:	86 ef       	ldi	r24, 0xF6	; 246
 422:	88 16       	cp	r8, r24
 424:	8f ef       	ldi	r24, 0xFF	; 255
 426:	98 06       	cpc	r9, r24
 428:	a8 06       	cpc	r10, r24
 42a:	8f e0       	ldi	r24, 0x0F	; 15
 42c:	b8 06       	cpc	r11, r24
 42e:	08 f0       	brcs	.+2      	; 0x432 <first_cluster_of_file+0x48>
 430:	7a c0       	rjmp	.+244    	; 0x526 <__stack+0xc7>
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
 432:	51 2c       	mov	r5, r1
 434:	41 2c       	mov	r4, r1
 436:	83 01       	movw	r16, r6
 438:	0f 5f       	subi	r16, 0xFF	; 255
 43a:	1f 4f       	sbci	r17, 0xFF	; 255
 43c:	67 c0       	rjmp	.+206    	; 0x50c <__stack+0xad>
   		{	
			dir = ( fs_dir * ) read_sector ( 
 43e:	84 85       	ldd	r24, Z+12	; 0x0c
 440:	95 85       	ldd	r25, Z+13	; 0x0d
 442:	0e 94 24 05 	call	0xa48	; 0xa48 <malloc>
 446:	ec 01       	movw	r28, r24
												(
													first_sector_of_cluster ( cluster_number )
 448:	c5 01       	movw	r24, r10
 44a:	b4 01       	movw	r22, r8
 44c:	0e 94 78 01 	call	0x2f0	; 0x2f0 <first_sector_of_cluster>

	while ( cluster_number < 0x0ffffff6 )
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
   		{	
			dir = ( fs_dir * ) read_sector ( 
 450:	6c 0d       	add	r22, r12
 452:	7d 1d       	adc	r23, r13
 454:	8e 1d       	adc	r24, r14
 456:	9f 1d       	adc	r25, r15
 458:	ae 01       	movw	r20, r28
 45a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <read_sector>
												malloc ( fat -> bytes_per_sector )
							    		   );

			for ( i = 0; i < 16; i ++ )
		    {
				for ( j = 0; f_name [ j ] == dir [ i ] . name [ j ]; j ++ );
 45e:	f3 01       	movw	r30, r6
 460:	30 80       	ld	r3, Z
 462:	ec 01       	movw	r28, r24
 464:	9c 01       	movw	r18, r24
 466:	3e 5f       	subi	r19, 0xFE	; 254
 468:	23 2c       	mov	r2, r3
 46a:	25 c0       	rjmp	.+74     	; 0x4b6 <__stack+0x57>
 46c:	4d 91       	ld	r20, X+
 46e:	51 91       	ld	r21, Z+
 470:	45 17       	cp	r20, r21
 472:	e1 f3       	breq	.-8      	; 0x46c <__stack+0xd>
 474:	01 c0       	rjmp	.+2      	; 0x478 <__stack+0x19>
 476:	42 2d       	mov	r20, r2

				if ( ! f_name [ j ] )
 478:	41 11       	cpse	r20, r1
 47a:	19 c0       	rjmp	.+50     	; 0x4ae <__stack+0x4f>
 47c:	ac 01       	movw	r20, r24
				{
					first_cluster = ( ( ( ( unsigned long ) dir [ i ] . firstclusterhi ) << 16 ) | dir [ i ] . firstclusterlo );
 47e:	fb 01       	movw	r30, r22
 480:	c4 88       	ldd	r12, Z+20	; 0x14
 482:	d5 88       	ldd	r13, Z+21	; 0x15
 484:	e1 2c       	mov	r14, r1
 486:	f1 2c       	mov	r15, r1
 488:	76 01       	movw	r14, r12
 48a:	dd 24       	eor	r13, r13
 48c:	cc 24       	eor	r12, r12
 48e:	82 8d       	ldd	r24, Z+26	; 0x1a
 490:	93 8d       	ldd	r25, Z+27	; 0x1b
 492:	a0 e0       	ldi	r26, 0x00	; 0
 494:	b0 e0       	ldi	r27, 0x00	; 0
 496:	c8 2a       	or	r12, r24
 498:	d9 2a       	or	r13, r25
 49a:	ea 2a       	or	r14, r26
 49c:	fb 2a       	or	r15, r27
					free ( dir );
 49e:	ca 01       	movw	r24, r20
 4a0:	0e 94 bc 05 	call	0xb78	; 0xb78 <free>
					return first_cluster;
 4a4:	6c 2d       	mov	r22, r12
 4a6:	7d 2d       	mov	r23, r13
 4a8:	8e 2d       	mov	r24, r14
 4aa:	9f 2d       	mov	r25, r15
 4ac:	45 c0       	rjmp	.+138    	; 0x538 <__stack+0xd9>
 4ae:	a0 96       	adiw	r28, 0x20	; 32
													+ sector_number
												),
												malloc ( fat -> bytes_per_sector )
							    		   );

			for ( i = 0; i < 16; i ++ )
 4b0:	c2 17       	cp	r28, r18
 4b2:	d3 07       	cpc	r29, r19
 4b4:	41 f0       	breq	.+16     	; 0x4c6 <__stack+0x67>
		    {
				for ( j = 0; f_name [ j ] == dir [ i ] . name [ j ]; j ++ );
 4b6:	be 01       	movw	r22, r28
 4b8:	48 81       	ld	r20, Y
 4ba:	34 12       	cpse	r3, r20
 4bc:	dc cf       	rjmp	.-72     	; 0x476 <__stack+0x17>
 4be:	d8 01       	movw	r26, r16
 4c0:	fe 01       	movw	r30, r28
 4c2:	31 96       	adiw	r30, 0x01	; 1
 4c4:	d3 cf       	rjmp	.-90     	; 0x46c <__stack+0xd>
					free ( dir );
					return first_cluster;
				}
				else;
			}
			free ( dir );
 4c6:	0e 94 bc 05 	call	0xb78	; 0xb78 <free>

	cluster_number = fat -> root_cluster;

	while ( cluster_number < 0x0ffffff6 )
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
 4ca:	ff ef       	ldi	r31, 0xFF	; 255
 4cc:	cf 1a       	sub	r12, r31
 4ce:	df 0a       	sbc	r13, r31
 4d0:	ef 0a       	sbc	r14, r31
 4d2:	ff 0a       	sbc	r15, r31
 4d4:	e0 91 6c 01 	lds	r30, 0x016C
 4d8:	f0 91 6d 01 	lds	r31, 0x016D
 4dc:	86 85       	ldd	r24, Z+14	; 0x0e
 4de:	97 85       	ldd	r25, Z+15	; 0x0f
 4e0:	a0 e0       	ldi	r26, 0x00	; 0
 4e2:	b0 e0       	ldi	r27, 0x00	; 0
 4e4:	c8 16       	cp	r12, r24
 4e6:	d9 06       	cpc	r13, r25
 4e8:	ea 06       	cpc	r14, r26
 4ea:	fb 06       	cpc	r15, r27
 4ec:	08 f4       	brcc	.+2      	; 0x4f0 <__stack+0x91>
 4ee:	a7 cf       	rjmp	.-178    	; 0x43e <first_cluster_of_file+0x54>
				}
				else;
			}
			free ( dir );
		}
		cluster_number = next_cluster_number ( cluster_number );
 4f0:	c5 01       	movw	r24, r10
 4f2:	b4 01       	movw	r22, r8
 4f4:	0e 94 97 01 	call	0x32e	; 0x32e <next_cluster_number>
 4f8:	4b 01       	movw	r8, r22
 4fa:	5c 01       	movw	r10, r24
	int i, j;
	fs_dir *dir;

	cluster_number = fat -> root_cluster;

	while ( cluster_number < 0x0ffffff6 )
 4fc:	86 ef       	ldi	r24, 0xF6	; 246
 4fe:	88 16       	cp	r8, r24
 500:	8f ef       	ldi	r24, 0xFF	; 255
 502:	98 06       	cpc	r9, r24
 504:	a8 06       	cpc	r10, r24
 506:	8f e0       	ldi	r24, 0x0F	; 15
 508:	b8 06       	cpc	r11, r24
 50a:	90 f4       	brcc	.+36     	; 0x530 <__stack+0xd1>
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
 50c:	e0 91 6c 01 	lds	r30, 0x016C
 510:	f0 91 6d 01 	lds	r31, 0x016D
 514:	86 85       	ldd	r24, Z+14	; 0x0e
 516:	97 85       	ldd	r25, Z+15	; 0x0f
 518:	89 2b       	or	r24, r25
 51a:	51 f3       	breq	.-44     	; 0x4f0 <__stack+0x91>
 51c:	c5 2c       	mov	r12, r5
 51e:	d4 2c       	mov	r13, r4
 520:	e1 2c       	mov	r14, r1
 522:	f1 2c       	mov	r15, r1
 524:	8c cf       	rjmp	.-232    	; 0x43e <first_cluster_of_file+0x54>
			}
			free ( dir );
		}
		cluster_number = next_cluster_number ( cluster_number );
	}
	return 0;
 526:	60 e0       	ldi	r22, 0x00	; 0
 528:	70 e0       	ldi	r23, 0x00	; 0
 52a:	80 e0       	ldi	r24, 0x00	; 0
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	04 c0       	rjmp	.+8      	; 0x538 <__stack+0xd9>
 530:	60 e0       	ldi	r22, 0x00	; 0
 532:	70 e0       	ldi	r23, 0x00	; 0
 534:	80 e0       	ldi	r24, 0x00	; 0
 536:	90 e0       	ldi	r25, 0x00	; 0
}
 538:	df 91       	pop	r29
 53a:	cf 91       	pop	r28
 53c:	1f 91       	pop	r17
 53e:	0f 91       	pop	r16
 540:	ff 90       	pop	r15
 542:	ef 90       	pop	r14
 544:	df 90       	pop	r13
 546:	cf 90       	pop	r12
 548:	bf 90       	pop	r11
 54a:	af 90       	pop	r10
 54c:	9f 90       	pop	r9
 54e:	8f 90       	pop	r8
 550:	7f 90       	pop	r7
 552:	6f 90       	pop	r6
 554:	5f 90       	pop	r5
 556:	4f 90       	pop	r4
 558:	3f 90       	pop	r3
 55a:	2f 90       	pop	r2
 55c:	08 95       	ret

0000055e <read_file>:
	return next_cluster;

}

unsigned char read_file ( char *f_name )
{
 55e:	2f 92       	push	r2
 560:	3f 92       	push	r3
 562:	4f 92       	push	r4
 564:	5f 92       	push	r5
 566:	6f 92       	push	r6
 568:	7f 92       	push	r7
 56a:	8f 92       	push	r8
 56c:	9f 92       	push	r9
 56e:	af 92       	push	r10
 570:	bf 92       	push	r11
 572:	cf 92       	push	r12
 574:	df 92       	push	r13
 576:	ef 92       	push	r14
 578:	ff 92       	push	r15
 57a:	0f 93       	push	r16
 57c:	1f 93       	push	r17
 57e:	cf 93       	push	r28
 580:	df 93       	push	r29
 582:	00 d0       	rcall	.+0      	; 0x584 <read_file+0x26>
 584:	00 d0       	rcall	.+0      	; 0x586 <read_file+0x28>
 586:	cd b7       	in	r28, 0x3d	; 61
 588:	de b7       	in	r29, 0x3e	; 62
	unsigned long cluster, first_sector;
	int i, j;
	char *data;

	cluster = first_cluster_of_file ( f_name );
 58a:	0e 94 f5 01 	call	0x3ea	; 0x3ea <first_cluster_of_file>
 58e:	2b 01       	movw	r4, r22
 590:	3c 01       	movw	r6, r24

	while ( 1 )
	{
		first_sector = first_sector_of_cluster ( cluster );
	
		for ( i = 0; i < fat -> sector_per_cluster; i ++ )
 592:	31 2c       	mov	r3, r1
 594:	21 2c       	mov	r2, r1
	  	{
	    	data = ( char * ) read_sector ( first_sector + i, malloc ( fat -> bytes_per_sector ) );

			for ( j = 0; j < fat -> bytes_per_sector; j ++ )
 596:	39 82       	std	Y+1, r3	; 0x01
 598:	2a 82       	std	Y+2, r2	; 0x02

	cluster = first_cluster_of_file ( f_name );

	while ( 1 )
	{
		first_sector = first_sector_of_cluster ( cluster );
 59a:	c3 01       	movw	r24, r6
 59c:	b2 01       	movw	r22, r4
 59e:	0e 94 78 01 	call	0x2f0	; 0x2f0 <first_sector_of_cluster>
 5a2:	6b 01       	movw	r12, r22
 5a4:	7c 01       	movw	r14, r24
	
		for ( i = 0; i < fat -> sector_per_cluster; i ++ )
 5a6:	e0 91 6c 01 	lds	r30, 0x016C
 5aa:	f0 91 6d 01 	lds	r31, 0x016D
 5ae:	86 85       	ldd	r24, Z+14	; 0x0e
 5b0:	97 85       	ldd	r25, Z+15	; 0x0f
 5b2:	89 2b       	or	r24, r25
 5b4:	09 f4       	brne	.+2      	; 0x5b8 <read_file+0x5a>
 5b6:	53 c0       	rjmp	.+166    	; 0x65e <read_file+0x100>
 5b8:	83 2c       	mov	r8, r3
 5ba:	92 2c       	mov	r9, r2
	  	{
	    	data = ( char * ) read_sector ( first_sector + i, malloc ( fat -> bytes_per_sector ) );
 5bc:	84 85       	ldd	r24, Z+12	; 0x0c
 5be:	95 85       	ldd	r25, Z+13	; 0x0d
 5c0:	0e 94 24 05 	call	0xa48	; 0xa48 <malloc>
 5c4:	ac 01       	movw	r20, r24
 5c6:	84 01       	movw	r16, r8
 5c8:	22 27       	eor	r18, r18
 5ca:	17 fd       	sbrc	r17, 7
 5cc:	20 95       	com	r18
 5ce:	32 2f       	mov	r19, r18
 5d0:	c9 01       	movw	r24, r18
 5d2:	b8 01       	movw	r22, r16
 5d4:	6c 0d       	add	r22, r12
 5d6:	7d 1d       	adc	r23, r13
 5d8:	8e 1d       	adc	r24, r14
 5da:	9f 1d       	adc	r25, r15
 5dc:	0e 94 69 01 	call	0x2d2	; 0x2d2 <read_sector>
 5e0:	5c 01       	movw	r10, r24

			for ( j = 0; j < fat -> bytes_per_sector; j ++ )
 5e2:	e0 91 6c 01 	lds	r30, 0x016C
 5e6:	f0 91 6d 01 	lds	r31, 0x016D
 5ea:	84 85       	ldd	r24, Z+12	; 0x0c
 5ec:	95 85       	ldd	r25, Z+13	; 0x0d
 5ee:	89 2b       	or	r24, r25
 5f0:	31 f1       	breq	.+76     	; 0x63e <read_file+0xe0>
			{
				if ( 0 == data [ j ] )
 5f2:	d5 01       	movw	r26, r10
 5f4:	8c 91       	ld	r24, X
 5f6:	81 11       	cpse	r24, r1
 5f8:	07 c0       	rjmp	.+14     	; 0x608 <read_file+0xaa>
 5fa:	38 c0       	rjmp	.+112    	; 0x66c <read_file+0x10e>
 5fc:	d8 01       	movw	r26, r16
 5fe:	8d 91       	ld	r24, X+
 600:	8d 01       	movw	r16, r26
 602:	81 11       	cpse	r24, r1
 604:	08 c0       	rjmp	.+16     	; 0x616 <read_file+0xb8>
 606:	32 c0       	rjmp	.+100    	; 0x66c <read_file+0x10e>
 608:	85 01       	movw	r16, r10
 60a:	0f 5f       	subi	r16, 0xFF	; 255
 60c:	1f 4f       	sbci	r17, 0xFF	; 255
	
		for ( i = 0; i < fat -> sector_per_cluster; i ++ )
	  	{
	    	data = ( char * ) read_sector ( first_sector + i, malloc ( fat -> bytes_per_sector ) );

			for ( j = 0; j < fat -> bytes_per_sector; j ++ )
 60e:	b9 81       	ldd	r27, Y+1	; 0x01
 610:	bb 83       	std	Y+3, r27	; 0x03
 612:	2a 81       	ldd	r18, Y+2	; 0x02
 614:	2c 83       	std	Y+4, r18	; 0x04
				if ( 0 == data [ j ] )
				{
					free ( data );
					return 0;
				}else;
				fat -> send_data_byte ( data [ j ] );
 616:	04 88       	ldd	r0, Z+20	; 0x14
 618:	f5 89       	ldd	r31, Z+21	; 0x15
 61a:	e0 2d       	mov	r30, r0
 61c:	09 95       	icall
	
		for ( i = 0; i < fat -> sector_per_cluster; i ++ )
	  	{
	    	data = ( char * ) read_sector ( first_sector + i, malloc ( fat -> bytes_per_sector ) );

			for ( j = 0; j < fat -> bytes_per_sector; j ++ )
 61e:	8b 81       	ldd	r24, Y+3	; 0x03
 620:	9c 81       	ldd	r25, Y+4	; 0x04
 622:	01 96       	adiw	r24, 0x01	; 1
 624:	9c 83       	std	Y+4, r25	; 0x04
 626:	8b 83       	std	Y+3, r24	; 0x03
 628:	e0 91 6c 01 	lds	r30, 0x016C
 62c:	f0 91 6d 01 	lds	r31, 0x016D
 630:	84 85       	ldd	r24, Z+12	; 0x0c
 632:	95 85       	ldd	r25, Z+13	; 0x0d
 634:	ab 81       	ldd	r26, Y+3	; 0x03
 636:	bc 81       	ldd	r27, Y+4	; 0x04
 638:	a8 17       	cp	r26, r24
 63a:	b9 07       	cpc	r27, r25
 63c:	f8 f2       	brcs	.-66     	; 0x5fc <read_file+0x9e>
					free ( data );
					return 0;
				}else;
				fat -> send_data_byte ( data [ j ] );
			}
			free ( data );
 63e:	c5 01       	movw	r24, r10
 640:	0e 94 bc 05 	call	0xb78	; 0xb78 <free>

	while ( 1 )
	{
		first_sector = first_sector_of_cluster ( cluster );
	
		for ( i = 0; i < fat -> sector_per_cluster; i ++ )
 644:	bf ef       	ldi	r27, 0xFF	; 255
 646:	8b 1a       	sub	r8, r27
 648:	9b 0a       	sbc	r9, r27
 64a:	e0 91 6c 01 	lds	r30, 0x016C
 64e:	f0 91 6d 01 	lds	r31, 0x016D
 652:	86 85       	ldd	r24, Z+14	; 0x0e
 654:	97 85       	ldd	r25, Z+15	; 0x0f
 656:	88 16       	cp	r8, r24
 658:	99 06       	cpc	r9, r25
 65a:	08 f4       	brcc	.+2      	; 0x65e <read_file+0x100>
 65c:	af cf       	rjmp	.-162    	; 0x5bc <read_file+0x5e>
				}else;
				fat -> send_data_byte ( data [ j ] );
			}
			free ( data );
		}
		cluster = next_cluster_number ( cluster );
 65e:	c3 01       	movw	r24, r6
 660:	b2 01       	movw	r22, r4
 662:	0e 94 97 01 	call	0x32e	; 0x32e <next_cluster_number>
 666:	2b 01       	movw	r4, r22
 668:	3c 01       	movw	r6, r24

    }
 66a:	97 cf       	rjmp	.-210    	; 0x59a <read_file+0x3c>

			for ( j = 0; j < fat -> bytes_per_sector; j ++ )
			{
				if ( 0 == data [ j ] )
				{
					free ( data );
 66c:	c5 01       	movw	r24, r10
 66e:	0e 94 bc 05 	call	0xb78	; 0xb78 <free>
		}
		cluster = next_cluster_number ( cluster );

    }
	return 0;
}
 672:	80 e0       	ldi	r24, 0x00	; 0
 674:	0f 90       	pop	r0
 676:	0f 90       	pop	r0
 678:	0f 90       	pop	r0
 67a:	0f 90       	pop	r0
 67c:	df 91       	pop	r29
 67e:	cf 91       	pop	r28
 680:	1f 91       	pop	r17
 682:	0f 91       	pop	r16
 684:	ff 90       	pop	r15
 686:	ef 90       	pop	r14
 688:	df 90       	pop	r13
 68a:	cf 90       	pop	r12
 68c:	bf 90       	pop	r11
 68e:	af 90       	pop	r10
 690:	9f 90       	pop	r9
 692:	8f 90       	pop	r8
 694:	7f 90       	pop	r7
 696:	6f 90       	pop	r6
 698:	5f 90       	pop	r5
 69a:	4f 90       	pop	r4
 69c:	3f 90       	pop	r3
 69e:	2f 90       	pop	r2
 6a0:	08 95       	ret

000006a2 <list_files>:

unsigned char list_files ( void )
{
 6a2:	2f 92       	push	r2
 6a4:	3f 92       	push	r3
 6a6:	4f 92       	push	r4
 6a8:	5f 92       	push	r5
 6aa:	6f 92       	push	r6
 6ac:	7f 92       	push	r7
 6ae:	8f 92       	push	r8
 6b0:	9f 92       	push	r9
 6b2:	af 92       	push	r10
 6b4:	bf 92       	push	r11
 6b6:	cf 92       	push	r12
 6b8:	df 92       	push	r13
 6ba:	ef 92       	push	r14
 6bc:	ff 92       	push	r15
 6be:	0f 93       	push	r16
 6c0:	1f 93       	push	r17
 6c2:	cf 93       	push	r28
 6c4:	df 93       	push	r29
	unsigned long cluster_number, sector_number;
	int i, j;
	fs_dir *dir;

	cluster_number = fat -> root_cluster;
 6c6:	e0 91 6c 01 	lds	r30, 0x016C
 6ca:	f0 91 6d 01 	lds	r31, 0x016D
 6ce:	80 84       	ldd	r8, Z+8	; 0x08
 6d0:	91 84       	ldd	r9, Z+9	; 0x09
 6d2:	a2 84       	ldd	r10, Z+10	; 0x0a
 6d4:	b3 84       	ldd	r11, Z+11	; 0x0b

	while ( cluster_number < 0x0ffffff6 )
 6d6:	86 ef       	ldi	r24, 0xF6	; 246
 6d8:	88 16       	cp	r8, r24
 6da:	8f ef       	ldi	r24, 0xFF	; 255
 6dc:	98 06       	cpc	r9, r24
 6de:	a8 06       	cpc	r10, r24
 6e0:	8f e0       	ldi	r24, 0x0F	; 15
 6e2:	b8 06       	cpc	r11, r24
 6e4:	08 f0       	brcs	.+2      	; 0x6e8 <list_files+0x46>
 6e6:	77 c0       	rjmp	.+238    	; 0x7d6 <list_files+0x134>
												malloc ( fat -> bytes_per_sector )
							    		   );

			for ( i = 0; i < 16; i ++ )
		    {
				if ( 0x20 == dir [ i ] . attrib )
 6e8:	31 2c       	mov	r3, r1
 6ea:	21 2c       	mov	r2, r1
 6ec:	67 c0       	rjmp	.+206    	; 0x7bc <list_files+0x11a>

	while ( cluster_number < 0x0ffffff6 )
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
   		{	
			dir = ( fs_dir * ) read_sector ( 
 6ee:	84 85       	ldd	r24, Z+12	; 0x0c
 6f0:	95 85       	ldd	r25, Z+13	; 0x0d
 6f2:	0e 94 24 05 	call	0xa48	; 0xa48 <malloc>
 6f6:	ec 01       	movw	r28, r24
												(
													first_sector_of_cluster ( cluster_number )
 6f8:	c5 01       	movw	r24, r10
 6fa:	b4 01       	movw	r22, r8
 6fc:	0e 94 78 01 	call	0x2f0	; 0x2f0 <first_sector_of_cluster>

	while ( cluster_number < 0x0ffffff6 )
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
   		{	
			dir = ( fs_dir * ) read_sector ( 
 700:	64 0d       	add	r22, r4
 702:	75 1d       	adc	r23, r5
 704:	86 1d       	adc	r24, r6
 706:	97 1d       	adc	r25, r7
 708:	ae 01       	movw	r20, r28
 70a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <read_sector>
 70e:	6c 01       	movw	r12, r24
 710:	e1 2c       	mov	r14, r1
 712:	f1 2c       	mov	r15, r1
 714:	f6 01       	movw	r30, r12
 716:	ee 0d       	add	r30, r14
 718:	ff 1d       	adc	r31, r15
												malloc ( fat -> bytes_per_sector )
							    		   );

			for ( i = 0; i < 16; i ++ )
		    {
				if ( 0x20 == dir [ i ] . attrib )
 71a:	83 85       	ldd	r24, Z+11	; 0x0b
 71c:	80 32       	cpi	r24, 0x20	; 32
 71e:	21 f5       	brne	.+72     	; 0x768 <list_files+0xc6>
 720:	8f 01       	movw	r16, r30
 722:	c3 2d       	mov	r28, r3
 724:	d2 2d       	mov	r29, r2
				{
					for ( j = 0; j < 11; j ++ )
						fat -> send_data_byte ( dir [ i ] . name [ j ] );
 726:	e0 91 6c 01 	lds	r30, 0x016C
 72a:	f0 91 6d 01 	lds	r31, 0x016D
 72e:	04 88       	ldd	r0, Z+20	; 0x14
 730:	f5 89       	ldd	r31, Z+21	; 0x15
 732:	e0 2d       	mov	r30, r0
 734:	d8 01       	movw	r26, r16
 736:	8d 91       	ld	r24, X+
 738:	8d 01       	movw	r16, r26
 73a:	09 95       	icall

			for ( i = 0; i < 16; i ++ )
		    {
				if ( 0x20 == dir [ i ] . attrib )
				{
					for ( j = 0; j < 11; j ++ )
 73c:	21 96       	adiw	r28, 0x01	; 1
 73e:	cb 30       	cpi	r28, 0x0B	; 11
 740:	d1 05       	cpc	r29, r1
 742:	89 f7       	brne	.-30     	; 0x726 <list_files+0x84>
						fat -> send_data_byte ( dir [ i ] . name [ j ] );
					fat -> send_data_byte ( '\n' );
 744:	e0 91 6c 01 	lds	r30, 0x016C
 748:	f0 91 6d 01 	lds	r31, 0x016D
 74c:	04 88       	ldd	r0, Z+20	; 0x14
 74e:	f5 89       	ldd	r31, Z+21	; 0x15
 750:	e0 2d       	mov	r30, r0
 752:	8a e0       	ldi	r24, 0x0A	; 10
 754:	09 95       	icall
					fat -> send_data_byte ( '\r' );
 756:	e0 91 6c 01 	lds	r30, 0x016C
 75a:	f0 91 6d 01 	lds	r31, 0x016D
 75e:	04 88       	ldd	r0, Z+20	; 0x14
 760:	f5 89       	ldd	r31, Z+21	; 0x15
 762:	e0 2d       	mov	r30, r0
 764:	8d e0       	ldi	r24, 0x0D	; 13
 766:	09 95       	icall
 768:	b0 e2       	ldi	r27, 0x20	; 32
 76a:	eb 0e       	add	r14, r27
 76c:	f1 1c       	adc	r15, r1
													+ sector_number
												),
												malloc ( fat -> bytes_per_sector )
							    		   );

			for ( i = 0; i < 16; i ++ )
 76e:	e1 14       	cp	r14, r1
 770:	82 e0       	ldi	r24, 0x02	; 2
 772:	f8 06       	cpc	r15, r24
 774:	79 f6       	brne	.-98     	; 0x714 <list_files+0x72>
					fat -> send_data_byte ( '\n' );
					fat -> send_data_byte ( '\r' );
				}
				else;
			}
			free ( dir );
 776:	c6 01       	movw	r24, r12
 778:	0e 94 bc 05 	call	0xb78	; 0xb78 <free>

	cluster_number = fat -> root_cluster;

	while ( cluster_number < 0x0ffffff6 )
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
 77c:	af ef       	ldi	r26, 0xFF	; 255
 77e:	4a 1a       	sub	r4, r26
 780:	5a 0a       	sbc	r5, r26
 782:	6a 0a       	sbc	r6, r26
 784:	7a 0a       	sbc	r7, r26
 786:	e0 91 6c 01 	lds	r30, 0x016C
 78a:	f0 91 6d 01 	lds	r31, 0x016D
 78e:	86 85       	ldd	r24, Z+14	; 0x0e
 790:	97 85       	ldd	r25, Z+15	; 0x0f
 792:	a0 e0       	ldi	r26, 0x00	; 0
 794:	b0 e0       	ldi	r27, 0x00	; 0
 796:	48 16       	cp	r4, r24
 798:	59 06       	cpc	r5, r25
 79a:	6a 06       	cpc	r6, r26
 79c:	7b 06       	cpc	r7, r27
 79e:	08 f4       	brcc	.+2      	; 0x7a2 <list_files+0x100>
 7a0:	a6 cf       	rjmp	.-180    	; 0x6ee <list_files+0x4c>
				}
				else;
			}
			free ( dir );
		}
		cluster_number = next_cluster_number ( cluster_number );
 7a2:	c5 01       	movw	r24, r10
 7a4:	b4 01       	movw	r22, r8
 7a6:	0e 94 97 01 	call	0x32e	; 0x32e <next_cluster_number>
 7aa:	4b 01       	movw	r8, r22
 7ac:	5c 01       	movw	r10, r24
	int i, j;
	fs_dir *dir;

	cluster_number = fat -> root_cluster;

	while ( cluster_number < 0x0ffffff6 )
 7ae:	66 3f       	cpi	r22, 0xF6	; 246
 7b0:	bf ef       	ldi	r27, 0xFF	; 255
 7b2:	7b 07       	cpc	r23, r27
 7b4:	8b 07       	cpc	r24, r27
 7b6:	bf e0       	ldi	r27, 0x0F	; 15
 7b8:	9b 07       	cpc	r25, r27
 7ba:	68 f4       	brcc	.+26     	; 0x7d6 <list_files+0x134>
	{	
		for ( sector_number = 0; sector_number < fat -> sector_per_cluster; sector_number ++ )
 7bc:	e0 91 6c 01 	lds	r30, 0x016C
 7c0:	f0 91 6d 01 	lds	r31, 0x016D
 7c4:	86 85       	ldd	r24, Z+14	; 0x0e
 7c6:	97 85       	ldd	r25, Z+15	; 0x0f
 7c8:	89 2b       	or	r24, r25
 7ca:	59 f3       	breq	.-42     	; 0x7a2 <list_files+0x100>
 7cc:	41 2c       	mov	r4, r1
 7ce:	51 2c       	mov	r5, r1
 7d0:	61 2c       	mov	r6, r1
 7d2:	71 2c       	mov	r7, r1
 7d4:	8c cf       	rjmp	.-232    	; 0x6ee <list_files+0x4c>
			free ( dir );
		}
		cluster_number = next_cluster_number ( cluster_number );
	}
	return 0;
}
 7d6:	80 e0       	ldi	r24, 0x00	; 0
 7d8:	df 91       	pop	r29
 7da:	cf 91       	pop	r28
 7dc:	1f 91       	pop	r17
 7de:	0f 91       	pop	r16
 7e0:	ff 90       	pop	r15
 7e2:	ef 90       	pop	r14
 7e4:	df 90       	pop	r13
 7e6:	cf 90       	pop	r12
 7e8:	bf 90       	pop	r11
 7ea:	af 90       	pop	r10
 7ec:	9f 90       	pop	r9
 7ee:	8f 90       	pop	r8
 7f0:	7f 90       	pop	r7
 7f2:	6f 90       	pop	r6
 7f4:	5f 90       	pop	r5
 7f6:	4f 90       	pop	r4
 7f8:	3f 90       	pop	r3
 7fa:	2f 90       	pop	r2
 7fc:	08 95       	ret

000007fe <putChar_UART>:
void putChar_UART(int kitu)
{
	while (inbit(UCSRA,UDRE)==0); //cho den khi bit UDRE=1 Neu = 1 thi viet code vao
 7fe:	5d 9b       	sbis	0x0b, 5	; 11
 800:	fe cf       	rjmp	.-4      	; 0x7fe <putChar_UART>
	UDR=kitu;
 802:	8c b9       	out	0x0c, r24	; 12
 804:	08 95       	ret

00000806 <print_UART>:
}
void print_UART(char* str)//******__HIEN THI CHUOI KI TU__*********************
{
 806:	cf 93       	push	r28
 808:	df 93       	push	r29
 80a:	ec 01       	movw	r28, r24
	int i;
	for (i=0; str[i]!=0; i++) 
 80c:	88 81       	ld	r24, Y
 80e:	88 23       	and	r24, r24
 810:	39 f0       	breq	.+14     	; 0x820 <print_UART+0x1a>
 812:	21 96       	adiw	r28, 0x01	; 1
	putChar_UART(str[i]);
 814:	90 e0       	ldi	r25, 0x00	; 0
 816:	0e 94 ff 03 	call	0x7fe	; 0x7fe <putChar_UART>
	UDR=kitu;
}
void print_UART(char* str)//******__HIEN THI CHUOI KI TU__*********************
{
	int i;
	for (i=0; str[i]!=0; i++) 
 81a:	89 91       	ld	r24, Y+
 81c:	81 11       	cpse	r24, r1
 81e:	fa cf       	rjmp	.-12     	; 0x814 <print_UART+0xe>
	putChar_UART(str[i]);
}
 820:	df 91       	pop	r29
 822:	cf 91       	pop	r28
 824:	08 95       	ret

00000826 <getchar_UART>:
	sprintf(dis, "%i", num);
	print_UART(dis);
}
int getchar_UART ( void )
{
	while ( ( UCSRA & ( 1 << RXC ) ) == 0 );
 826:	5f 9b       	sbis	0x0b, 7	; 11
 828:	fe cf       	rjmp	.-4      	; 0x826 <getchar_UART>
	// Do nothing until data have been received and is ready to be read from UDR
	return ( UDR ); // return the byte
 82a:	8c b1       	in	r24, 0x0c	; 12
}
 82c:	90 e0       	ldi	r25, 0x00	; 0
 82e:	08 95       	ret

00000830 <init_UART>:
void init_UART()

{
	//UART
	UBRRH=0;		//set toc do truyen baud
 830:	10 bc       	out	0x20, r1	; 32
	UBRRL=51;
 832:	83 e3       	ldi	r24, 0x33	; 51
 834:	89 b9       	out	0x09, r24	; 9
	UCSRC=(1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
 836:	86 e8       	ldi	r24, 0x86	; 134
 838:	80 bd       	out	0x20, r24	; 32
	UCSRB=(1<<TXEN)|(1<<RXEN)|(1<<RXCIE);
 83a:	88 e9       	ldi	r24, 0x98	; 152
 83c:	8a b9       	out	0x0a, r24	; 10
 83e:	08 95       	ret

00000840 <main>:
int main ( void )
{
	char x;
	int i;
	char *p = "         ";
	sei();
 840:	78 94       	sei
	init_LCD();
 842:	0e 94 95 00 	call	0x12a	; 0x12a <init_LCD>
	init_UART();
 846:	0e 94 18 04 	call	0x830	; 0x830 <init_UART>
	//init_devices ();
	
	print_LCD ( "    ENGINEERS   " );
 84a:	8d e7       	ldi	r24, 0x7D	; 125
 84c:	90 e0       	ldi	r25, 0x00	; 0
 84e:	0e 94 de 00 	call	0x1bc	; 0x1bc <print_LCD>
	move_LCD(2,1);
 852:	61 e0       	ldi	r22, 0x01	; 1
 854:	82 e0       	ldi	r24, 0x02	; 2
 856:	0e 94 c4 00 	call	0x188	; 0x188 <move_LCD>
	sdsc_init();
 85a:	0e 94 5e 01 	call	0x2bc	; 0x2bc <sdsc_init>
	print_LCD ( "     ok     " );
 85e:	8e e8       	ldi	r24, 0x8E	; 142
 860:	90 e0       	ldi	r25, 0x00	; 0
 862:	0e 94 de 00 	call	0x1bc	; 0x1bc <print_LCD>
move_LCD(2,1);
 866:	61 e0       	ldi	r22, 0x01	; 1
 868:	82 e0       	ldi	r24, 0x02	; 2
 86a:	0e 94 c4 00 	call	0x188	; 0x188 <move_LCD>
	print_UART ( "\n======== ENGINEERS GARAGE SDCARD INTERFACING =======\n" );
 86e:	8b e9       	ldi	r24, 0x9B	; 155
 870:	90 e0       	ldi	r25, 0x00	; 0
 872:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
	print_UART ( "\nSDSC card detected\n" );
 876:	82 ed       	ldi	r24, 0xD2	; 210
 878:	90 e0       	ldi	r25, 0x00	; 0
 87a:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
 87e:	0f 2e       	mov	r0, r31
 880:	f0 e7       	ldi	r31, 0x70	; 112
 882:	cf 2e       	mov	r12, r31
 884:	f0 e0       	ldi	r31, 0x00	; 0
 886:	df 2e       	mov	r13, r31
 888:	f0 2d       	mov	r31, r0
		break;

		case '2':
		print_UART ( "\nEnter the file name : " );

		for ( i = 0; i < 9; i ++ )
 88a:	91 2c       	mov	r9, r1
 88c:	a1 2c       	mov	r10, r1
move_LCD(2,1);
	print_UART ( "\n======== ENGINEERS GARAGE SDCARD INTERFACING =======\n" );
	print_UART ( "\nSDSC card detected\n" );

	MENU:
	print_UART ( "\nOPTIONS:\n" );
 88e:	87 ee       	ldi	r24, 0xE7	; 231
 890:	90 e0       	ldi	r25, 0x00	; 0
 892:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
	print_UART ( "\n  1  : LIST ALL FILES\n" );
 896:	82 ef       	ldi	r24, 0xF2	; 242
 898:	90 e0       	ldi	r25, 0x00	; 0
 89a:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
	print_UART ( "\n  2  : READ A FILE\n" );
 89e:	8a e0       	ldi	r24, 0x0A	; 10
 8a0:	91 e0       	ldi	r25, 0x01	; 1
 8a2:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
	print_UART ( "\nEnter option : " );
 8a6:	8f e1       	ldi	r24, 0x1F	; 31
 8a8:	91 e0       	ldi	r25, 0x01	; 1
 8aa:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>

	switch ( getchar_UART () )
 8ae:	0e 94 13 04 	call	0x826	; 0x826 <getchar_UART>
 8b2:	81 33       	cpi	r24, 0x31	; 49
 8b4:	91 05       	cpc	r25, r1
 8b6:	19 f0       	breq	.+6      	; 0x8be <main+0x7e>
 8b8:	c2 97       	sbiw	r24, 0x32	; 50
 8ba:	51 f0       	breq	.+20     	; 0x8d0 <main+0x90>
 8bc:	e8 cf       	rjmp	.-48     	; 0x88e <main+0x4e>
	{
		case '1':
		clr_LCD ();
 8be:	0e 94 ed 00 	call	0x1da	; 0x1da <clr_LCD>
		print_UART ( "LISTING FILES ..." );
 8c2:	80 e3       	ldi	r24, 0x30	; 48
 8c4:	91 e0       	ldi	r25, 0x01	; 1
 8c6:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
		list_files ();
 8ca:	0e 94 51 03 	call	0x6a2	; 0x6a2 <list_files>
		break;
 8ce:	df cf       	rjmp	.-66     	; 0x88e <main+0x4e>

		case '2':
		print_UART ( "\nEnter the file name : " );
 8d0:	82 e4       	ldi	r24, 0x42	; 66
 8d2:	91 e0       	ldi	r25, 0x01	; 1
 8d4:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
 8d8:	76 01       	movw	r14, r12

		for ( i = 0; i < 9; i ++ )
 8da:	09 2d       	mov	r16, r9
 8dc:	1a 2d       	mov	r17, r10
		{
			x = getchar_UART ();
 8de:	0e 94 13 04 	call	0x826	; 0x826 <getchar_UART>
 8e2:	ec 01       	movw	r28, r24
			putChar_UART (x);
 8e4:	99 27       	eor	r25, r25
 8e6:	0e 94 ff 03 	call	0x7fe	; 0x7fe <putChar_UART>
			if ( '\r' == x )
 8ea:	8d e0       	ldi	r24, 0x0D	; 13
 8ec:	c8 17       	cp	r28, r24
 8ee:	41 f0       	breq	.+16     	; 0x900 <main+0xc0>
			break;
			else
			p [ i ] = x;
 8f0:	f7 01       	movw	r30, r14
 8f2:	c1 93       	st	Z+, r28
 8f4:	7f 01       	movw	r14, r30
		break;

		case '2':
		print_UART ( "\nEnter the file name : " );

		for ( i = 0; i < 9; i ++ )
 8f6:	0f 5f       	subi	r16, 0xFF	; 255
 8f8:	1f 4f       	sbci	r17, 0xFF	; 255
 8fa:	09 30       	cpi	r16, 0x09	; 9
 8fc:	11 05       	cpc	r17, r1
 8fe:	79 f7       	brne	.-34     	; 0x8de <main+0x9e>
			if ( '\r' == x )
			break;
			else
			p [ i ] = x;
		}
		p [ i ] = '\0';
 900:	f8 01       	movw	r30, r16
 902:	e0 59       	subi	r30, 0x90	; 144
 904:	ff 4f       	sbci	r31, 0xFF	; 255
 906:	10 82       	st	Z, r1
		
		clr_LCD ();
 908:	0e 94 ed 00 	call	0x1da	; 0x1da <clr_LCD>
		print_UART ( "READING FILE ..." );
 90c:	8a e5       	ldi	r24, 0x5A	; 90
 90e:	91 e0       	ldi	r25, 0x01	; 1
 910:	0e 94 03 04 	call	0x806	; 0x806 <print_UART>
		read_file ( p );
 914:	c6 01       	movw	r24, r12
 916:	0e 94 af 02 	call	0x55e	; 0x55e <read_file>
 91a:	b9 cf       	rjmp	.-142    	; 0x88e <main+0x4e>

0000091c <__fixsfsi>:
 91c:	04 d0       	rcall	.+8      	; 0x926 <__fixunssfsi>
 91e:	68 94       	set
 920:	b1 11       	cpse	r27, r1
 922:	50 c0       	rjmp	.+160    	; 0x9c4 <__fp_szero>
 924:	08 95       	ret

00000926 <__fixunssfsi>:
 926:	33 d0       	rcall	.+102    	; 0x98e <__fp_splitA>
 928:	88 f0       	brcs	.+34     	; 0x94c <__fixunssfsi+0x26>
 92a:	9f 57       	subi	r25, 0x7F	; 127
 92c:	90 f0       	brcs	.+36     	; 0x952 <__fixunssfsi+0x2c>
 92e:	b9 2f       	mov	r27, r25
 930:	99 27       	eor	r25, r25
 932:	b7 51       	subi	r27, 0x17	; 23
 934:	a0 f0       	brcs	.+40     	; 0x95e <__fixunssfsi+0x38>
 936:	d1 f0       	breq	.+52     	; 0x96c <__fixunssfsi+0x46>
 938:	66 0f       	add	r22, r22
 93a:	77 1f       	adc	r23, r23
 93c:	88 1f       	adc	r24, r24
 93e:	99 1f       	adc	r25, r25
 940:	1a f0       	brmi	.+6      	; 0x948 <__fixunssfsi+0x22>
 942:	ba 95       	dec	r27
 944:	c9 f7       	brne	.-14     	; 0x938 <__fixunssfsi+0x12>
 946:	12 c0       	rjmp	.+36     	; 0x96c <__fixunssfsi+0x46>
 948:	b1 30       	cpi	r27, 0x01	; 1
 94a:	81 f0       	breq	.+32     	; 0x96c <__fixunssfsi+0x46>
 94c:	3a d0       	rcall	.+116    	; 0x9c2 <__fp_zero>
 94e:	b1 e0       	ldi	r27, 0x01	; 1
 950:	08 95       	ret
 952:	37 c0       	rjmp	.+110    	; 0x9c2 <__fp_zero>
 954:	67 2f       	mov	r22, r23
 956:	78 2f       	mov	r23, r24
 958:	88 27       	eor	r24, r24
 95a:	b8 5f       	subi	r27, 0xF8	; 248
 95c:	39 f0       	breq	.+14     	; 0x96c <__fixunssfsi+0x46>
 95e:	b9 3f       	cpi	r27, 0xF9	; 249
 960:	cc f3       	brlt	.-14     	; 0x954 <__fixunssfsi+0x2e>
 962:	86 95       	lsr	r24
 964:	77 95       	ror	r23
 966:	67 95       	ror	r22
 968:	b3 95       	inc	r27
 96a:	d9 f7       	brne	.-10     	; 0x962 <__fixunssfsi+0x3c>
 96c:	3e f4       	brtc	.+14     	; 0x97c <__fixunssfsi+0x56>
 96e:	90 95       	com	r25
 970:	80 95       	com	r24
 972:	70 95       	com	r23
 974:	61 95       	neg	r22
 976:	7f 4f       	sbci	r23, 0xFF	; 255
 978:	8f 4f       	sbci	r24, 0xFF	; 255
 97a:	9f 4f       	sbci	r25, 0xFF	; 255
 97c:	08 95       	ret

0000097e <__fp_split3>:
 97e:	57 fd       	sbrc	r21, 7
 980:	90 58       	subi	r25, 0x80	; 128
 982:	44 0f       	add	r20, r20
 984:	55 1f       	adc	r21, r21
 986:	59 f0       	breq	.+22     	; 0x99e <__fp_splitA+0x10>
 988:	5f 3f       	cpi	r21, 0xFF	; 255
 98a:	71 f0       	breq	.+28     	; 0x9a8 <__fp_splitA+0x1a>
 98c:	47 95       	ror	r20

0000098e <__fp_splitA>:
 98e:	88 0f       	add	r24, r24
 990:	97 fb       	bst	r25, 7
 992:	99 1f       	adc	r25, r25
 994:	61 f0       	breq	.+24     	; 0x9ae <__fp_splitA+0x20>
 996:	9f 3f       	cpi	r25, 0xFF	; 255
 998:	79 f0       	breq	.+30     	; 0x9b8 <__fp_splitA+0x2a>
 99a:	87 95       	ror	r24
 99c:	08 95       	ret
 99e:	12 16       	cp	r1, r18
 9a0:	13 06       	cpc	r1, r19
 9a2:	14 06       	cpc	r1, r20
 9a4:	55 1f       	adc	r21, r21
 9a6:	f2 cf       	rjmp	.-28     	; 0x98c <__fp_split3+0xe>
 9a8:	46 95       	lsr	r20
 9aa:	f1 df       	rcall	.-30     	; 0x98e <__fp_splitA>
 9ac:	08 c0       	rjmp	.+16     	; 0x9be <__fp_splitA+0x30>
 9ae:	16 16       	cp	r1, r22
 9b0:	17 06       	cpc	r1, r23
 9b2:	18 06       	cpc	r1, r24
 9b4:	99 1f       	adc	r25, r25
 9b6:	f1 cf       	rjmp	.-30     	; 0x99a <__fp_splitA+0xc>
 9b8:	86 95       	lsr	r24
 9ba:	71 05       	cpc	r23, r1
 9bc:	61 05       	cpc	r22, r1
 9be:	08 94       	sec
 9c0:	08 95       	ret

000009c2 <__fp_zero>:
 9c2:	e8 94       	clt

000009c4 <__fp_szero>:
 9c4:	bb 27       	eor	r27, r27
 9c6:	66 27       	eor	r22, r22
 9c8:	77 27       	eor	r23, r23
 9ca:	cb 01       	movw	r24, r22
 9cc:	97 f9       	bld	r25, 7
 9ce:	08 95       	ret

000009d0 <__udivmodsi4>:
 9d0:	a1 e2       	ldi	r26, 0x21	; 33
 9d2:	1a 2e       	mov	r1, r26
 9d4:	aa 1b       	sub	r26, r26
 9d6:	bb 1b       	sub	r27, r27
 9d8:	fd 01       	movw	r30, r26
 9da:	0d c0       	rjmp	.+26     	; 0x9f6 <__udivmodsi4_ep>

000009dc <__udivmodsi4_loop>:
 9dc:	aa 1f       	adc	r26, r26
 9de:	bb 1f       	adc	r27, r27
 9e0:	ee 1f       	adc	r30, r30
 9e2:	ff 1f       	adc	r31, r31
 9e4:	a2 17       	cp	r26, r18
 9e6:	b3 07       	cpc	r27, r19
 9e8:	e4 07       	cpc	r30, r20
 9ea:	f5 07       	cpc	r31, r21
 9ec:	20 f0       	brcs	.+8      	; 0x9f6 <__udivmodsi4_ep>
 9ee:	a2 1b       	sub	r26, r18
 9f0:	b3 0b       	sbc	r27, r19
 9f2:	e4 0b       	sbc	r30, r20
 9f4:	f5 0b       	sbc	r31, r21

000009f6 <__udivmodsi4_ep>:
 9f6:	66 1f       	adc	r22, r22
 9f8:	77 1f       	adc	r23, r23
 9fa:	88 1f       	adc	r24, r24
 9fc:	99 1f       	adc	r25, r25
 9fe:	1a 94       	dec	r1
 a00:	69 f7       	brne	.-38     	; 0x9dc <__udivmodsi4_loop>
 a02:	60 95       	com	r22
 a04:	70 95       	com	r23
 a06:	80 95       	com	r24
 a08:	90 95       	com	r25
 a0a:	9b 01       	movw	r18, r22
 a0c:	ac 01       	movw	r20, r24
 a0e:	bd 01       	movw	r22, r26
 a10:	cf 01       	movw	r24, r30
 a12:	08 95       	ret

00000a14 <__muluhisi3>:
 a14:	0e 94 15 05 	call	0xa2a	; 0xa2a <__umulhisi3>
 a18:	a5 9f       	mul	r26, r21
 a1a:	90 0d       	add	r25, r0
 a1c:	b4 9f       	mul	r27, r20
 a1e:	90 0d       	add	r25, r0
 a20:	a4 9f       	mul	r26, r20
 a22:	80 0d       	add	r24, r0
 a24:	91 1d       	adc	r25, r1
 a26:	11 24       	eor	r1, r1
 a28:	08 95       	ret

00000a2a <__umulhisi3>:
 a2a:	a2 9f       	mul	r26, r18
 a2c:	b0 01       	movw	r22, r0
 a2e:	b3 9f       	mul	r27, r19
 a30:	c0 01       	movw	r24, r0
 a32:	a3 9f       	mul	r26, r19
 a34:	70 0d       	add	r23, r0
 a36:	81 1d       	adc	r24, r1
 a38:	11 24       	eor	r1, r1
 a3a:	91 1d       	adc	r25, r1
 a3c:	b2 9f       	mul	r27, r18
 a3e:	70 0d       	add	r23, r0
 a40:	81 1d       	adc	r24, r1
 a42:	11 24       	eor	r1, r1
 a44:	91 1d       	adc	r25, r1
 a46:	08 95       	ret

00000a48 <malloc>:
 a48:	cf 93       	push	r28
 a4a:	df 93       	push	r29
 a4c:	82 30       	cpi	r24, 0x02	; 2
 a4e:	91 05       	cpc	r25, r1
 a50:	10 f4       	brcc	.+4      	; 0xa56 <malloc+0xe>
 a52:	82 e0       	ldi	r24, 0x02	; 2
 a54:	90 e0       	ldi	r25, 0x00	; 0
 a56:	e0 91 72 01 	lds	r30, 0x0172
 a5a:	f0 91 73 01 	lds	r31, 0x0173
 a5e:	20 e0       	ldi	r18, 0x00	; 0
 a60:	30 e0       	ldi	r19, 0x00	; 0
 a62:	a0 e0       	ldi	r26, 0x00	; 0
 a64:	b0 e0       	ldi	r27, 0x00	; 0
 a66:	30 97       	sbiw	r30, 0x00	; 0
 a68:	39 f1       	breq	.+78     	; 0xab8 <malloc+0x70>
 a6a:	40 81       	ld	r20, Z
 a6c:	51 81       	ldd	r21, Z+1	; 0x01
 a6e:	48 17       	cp	r20, r24
 a70:	59 07       	cpc	r21, r25
 a72:	b8 f0       	brcs	.+46     	; 0xaa2 <malloc+0x5a>
 a74:	48 17       	cp	r20, r24
 a76:	59 07       	cpc	r21, r25
 a78:	71 f4       	brne	.+28     	; 0xa96 <malloc+0x4e>
 a7a:	82 81       	ldd	r24, Z+2	; 0x02
 a7c:	93 81       	ldd	r25, Z+3	; 0x03
 a7e:	10 97       	sbiw	r26, 0x00	; 0
 a80:	29 f0       	breq	.+10     	; 0xa8c <malloc+0x44>
 a82:	13 96       	adiw	r26, 0x03	; 3
 a84:	9c 93       	st	X, r25
 a86:	8e 93       	st	-X, r24
 a88:	12 97       	sbiw	r26, 0x02	; 2
 a8a:	2c c0       	rjmp	.+88     	; 0xae4 <malloc+0x9c>
 a8c:	90 93 73 01 	sts	0x0173, r25
 a90:	80 93 72 01 	sts	0x0172, r24
 a94:	27 c0       	rjmp	.+78     	; 0xae4 <malloc+0x9c>
 a96:	21 15       	cp	r18, r1
 a98:	31 05       	cpc	r19, r1
 a9a:	31 f0       	breq	.+12     	; 0xaa8 <malloc+0x60>
 a9c:	42 17       	cp	r20, r18
 a9e:	53 07       	cpc	r21, r19
 aa0:	18 f0       	brcs	.+6      	; 0xaa8 <malloc+0x60>
 aa2:	a9 01       	movw	r20, r18
 aa4:	db 01       	movw	r26, r22
 aa6:	01 c0       	rjmp	.+2      	; 0xaaa <malloc+0x62>
 aa8:	ef 01       	movw	r28, r30
 aaa:	9a 01       	movw	r18, r20
 aac:	bd 01       	movw	r22, r26
 aae:	df 01       	movw	r26, r30
 ab0:	02 80       	ldd	r0, Z+2	; 0x02
 ab2:	f3 81       	ldd	r31, Z+3	; 0x03
 ab4:	e0 2d       	mov	r30, r0
 ab6:	d7 cf       	rjmp	.-82     	; 0xa66 <malloc+0x1e>
 ab8:	21 15       	cp	r18, r1
 aba:	31 05       	cpc	r19, r1
 abc:	f9 f0       	breq	.+62     	; 0xafc <malloc+0xb4>
 abe:	28 1b       	sub	r18, r24
 ac0:	39 0b       	sbc	r19, r25
 ac2:	24 30       	cpi	r18, 0x04	; 4
 ac4:	31 05       	cpc	r19, r1
 ac6:	80 f4       	brcc	.+32     	; 0xae8 <malloc+0xa0>
 ac8:	8a 81       	ldd	r24, Y+2	; 0x02
 aca:	9b 81       	ldd	r25, Y+3	; 0x03
 acc:	61 15       	cp	r22, r1
 ace:	71 05       	cpc	r23, r1
 ad0:	21 f0       	breq	.+8      	; 0xada <malloc+0x92>
 ad2:	fb 01       	movw	r30, r22
 ad4:	93 83       	std	Z+3, r25	; 0x03
 ad6:	82 83       	std	Z+2, r24	; 0x02
 ad8:	04 c0       	rjmp	.+8      	; 0xae2 <malloc+0x9a>
 ada:	90 93 73 01 	sts	0x0173, r25
 ade:	80 93 72 01 	sts	0x0172, r24
 ae2:	fe 01       	movw	r30, r28
 ae4:	32 96       	adiw	r30, 0x02	; 2
 ae6:	44 c0       	rjmp	.+136    	; 0xb70 <malloc+0x128>
 ae8:	fe 01       	movw	r30, r28
 aea:	e2 0f       	add	r30, r18
 aec:	f3 1f       	adc	r31, r19
 aee:	81 93       	st	Z+, r24
 af0:	91 93       	st	Z+, r25
 af2:	22 50       	subi	r18, 0x02	; 2
 af4:	31 09       	sbc	r19, r1
 af6:	39 83       	std	Y+1, r19	; 0x01
 af8:	28 83       	st	Y, r18
 afa:	3a c0       	rjmp	.+116    	; 0xb70 <malloc+0x128>
 afc:	20 91 70 01 	lds	r18, 0x0170
 b00:	30 91 71 01 	lds	r19, 0x0171
 b04:	23 2b       	or	r18, r19
 b06:	41 f4       	brne	.+16     	; 0xb18 <malloc+0xd0>
 b08:	20 91 62 00 	lds	r18, 0x0062
 b0c:	30 91 63 00 	lds	r19, 0x0063
 b10:	30 93 71 01 	sts	0x0171, r19
 b14:	20 93 70 01 	sts	0x0170, r18
 b18:	20 91 60 00 	lds	r18, 0x0060
 b1c:	30 91 61 00 	lds	r19, 0x0061
 b20:	21 15       	cp	r18, r1
 b22:	31 05       	cpc	r19, r1
 b24:	41 f4       	brne	.+16     	; 0xb36 <malloc+0xee>
 b26:	2d b7       	in	r18, 0x3d	; 61
 b28:	3e b7       	in	r19, 0x3e	; 62
 b2a:	40 91 64 00 	lds	r20, 0x0064
 b2e:	50 91 65 00 	lds	r21, 0x0065
 b32:	24 1b       	sub	r18, r20
 b34:	35 0b       	sbc	r19, r21
 b36:	e0 91 70 01 	lds	r30, 0x0170
 b3a:	f0 91 71 01 	lds	r31, 0x0171
 b3e:	e2 17       	cp	r30, r18
 b40:	f3 07       	cpc	r31, r19
 b42:	a0 f4       	brcc	.+40     	; 0xb6c <malloc+0x124>
 b44:	2e 1b       	sub	r18, r30
 b46:	3f 0b       	sbc	r19, r31
 b48:	28 17       	cp	r18, r24
 b4a:	39 07       	cpc	r19, r25
 b4c:	78 f0       	brcs	.+30     	; 0xb6c <malloc+0x124>
 b4e:	ac 01       	movw	r20, r24
 b50:	4e 5f       	subi	r20, 0xFE	; 254
 b52:	5f 4f       	sbci	r21, 0xFF	; 255
 b54:	24 17       	cp	r18, r20
 b56:	35 07       	cpc	r19, r21
 b58:	48 f0       	brcs	.+18     	; 0xb6c <malloc+0x124>
 b5a:	4e 0f       	add	r20, r30
 b5c:	5f 1f       	adc	r21, r31
 b5e:	50 93 71 01 	sts	0x0171, r21
 b62:	40 93 70 01 	sts	0x0170, r20
 b66:	81 93       	st	Z+, r24
 b68:	91 93       	st	Z+, r25
 b6a:	02 c0       	rjmp	.+4      	; 0xb70 <malloc+0x128>
 b6c:	e0 e0       	ldi	r30, 0x00	; 0
 b6e:	f0 e0       	ldi	r31, 0x00	; 0
 b70:	cf 01       	movw	r24, r30
 b72:	df 91       	pop	r29
 b74:	cf 91       	pop	r28
 b76:	08 95       	ret

00000b78 <free>:
 b78:	cf 93       	push	r28
 b7a:	df 93       	push	r29
 b7c:	00 97       	sbiw	r24, 0x00	; 0
 b7e:	09 f4       	brne	.+2      	; 0xb82 <free+0xa>
 b80:	87 c0       	rjmp	.+270    	; 0xc90 <free+0x118>
 b82:	fc 01       	movw	r30, r24
 b84:	32 97       	sbiw	r30, 0x02	; 2
 b86:	13 82       	std	Z+3, r1	; 0x03
 b88:	12 82       	std	Z+2, r1	; 0x02
 b8a:	c0 91 72 01 	lds	r28, 0x0172
 b8e:	d0 91 73 01 	lds	r29, 0x0173
 b92:	20 97       	sbiw	r28, 0x00	; 0
 b94:	81 f4       	brne	.+32     	; 0xbb6 <free+0x3e>
 b96:	20 81       	ld	r18, Z
 b98:	31 81       	ldd	r19, Z+1	; 0x01
 b9a:	28 0f       	add	r18, r24
 b9c:	39 1f       	adc	r19, r25
 b9e:	80 91 70 01 	lds	r24, 0x0170
 ba2:	90 91 71 01 	lds	r25, 0x0171
 ba6:	82 17       	cp	r24, r18
 ba8:	93 07       	cpc	r25, r19
 baa:	79 f5       	brne	.+94     	; 0xc0a <free+0x92>
 bac:	f0 93 71 01 	sts	0x0171, r31
 bb0:	e0 93 70 01 	sts	0x0170, r30
 bb4:	6d c0       	rjmp	.+218    	; 0xc90 <free+0x118>
 bb6:	de 01       	movw	r26, r28
 bb8:	20 e0       	ldi	r18, 0x00	; 0
 bba:	30 e0       	ldi	r19, 0x00	; 0
 bbc:	ae 17       	cp	r26, r30
 bbe:	bf 07       	cpc	r27, r31
 bc0:	50 f4       	brcc	.+20     	; 0xbd6 <free+0x5e>
 bc2:	12 96       	adiw	r26, 0x02	; 2
 bc4:	4d 91       	ld	r20, X+
 bc6:	5c 91       	ld	r21, X
 bc8:	13 97       	sbiw	r26, 0x03	; 3
 bca:	9d 01       	movw	r18, r26
 bcc:	41 15       	cp	r20, r1
 bce:	51 05       	cpc	r21, r1
 bd0:	09 f1       	breq	.+66     	; 0xc14 <free+0x9c>
 bd2:	da 01       	movw	r26, r20
 bd4:	f3 cf       	rjmp	.-26     	; 0xbbc <free+0x44>
 bd6:	b3 83       	std	Z+3, r27	; 0x03
 bd8:	a2 83       	std	Z+2, r26	; 0x02
 bda:	40 81       	ld	r20, Z
 bdc:	51 81       	ldd	r21, Z+1	; 0x01
 bde:	84 0f       	add	r24, r20
 be0:	95 1f       	adc	r25, r21
 be2:	8a 17       	cp	r24, r26
 be4:	9b 07       	cpc	r25, r27
 be6:	71 f4       	brne	.+28     	; 0xc04 <free+0x8c>
 be8:	8d 91       	ld	r24, X+
 bea:	9c 91       	ld	r25, X
 bec:	11 97       	sbiw	r26, 0x01	; 1
 bee:	84 0f       	add	r24, r20
 bf0:	95 1f       	adc	r25, r21
 bf2:	02 96       	adiw	r24, 0x02	; 2
 bf4:	91 83       	std	Z+1, r25	; 0x01
 bf6:	80 83       	st	Z, r24
 bf8:	12 96       	adiw	r26, 0x02	; 2
 bfa:	8d 91       	ld	r24, X+
 bfc:	9c 91       	ld	r25, X
 bfe:	13 97       	sbiw	r26, 0x03	; 3
 c00:	93 83       	std	Z+3, r25	; 0x03
 c02:	82 83       	std	Z+2, r24	; 0x02
 c04:	21 15       	cp	r18, r1
 c06:	31 05       	cpc	r19, r1
 c08:	29 f4       	brne	.+10     	; 0xc14 <free+0x9c>
 c0a:	f0 93 73 01 	sts	0x0173, r31
 c0e:	e0 93 72 01 	sts	0x0172, r30
 c12:	3e c0       	rjmp	.+124    	; 0xc90 <free+0x118>
 c14:	d9 01       	movw	r26, r18
 c16:	13 96       	adiw	r26, 0x03	; 3
 c18:	fc 93       	st	X, r31
 c1a:	ee 93       	st	-X, r30
 c1c:	12 97       	sbiw	r26, 0x02	; 2
 c1e:	4d 91       	ld	r20, X+
 c20:	5d 91       	ld	r21, X+
 c22:	a4 0f       	add	r26, r20
 c24:	b5 1f       	adc	r27, r21
 c26:	ea 17       	cp	r30, r26
 c28:	fb 07       	cpc	r31, r27
 c2a:	79 f4       	brne	.+30     	; 0xc4a <free+0xd2>
 c2c:	80 81       	ld	r24, Z
 c2e:	91 81       	ldd	r25, Z+1	; 0x01
 c30:	84 0f       	add	r24, r20
 c32:	95 1f       	adc	r25, r21
 c34:	02 96       	adiw	r24, 0x02	; 2
 c36:	d9 01       	movw	r26, r18
 c38:	11 96       	adiw	r26, 0x01	; 1
 c3a:	9c 93       	st	X, r25
 c3c:	8e 93       	st	-X, r24
 c3e:	82 81       	ldd	r24, Z+2	; 0x02
 c40:	93 81       	ldd	r25, Z+3	; 0x03
 c42:	13 96       	adiw	r26, 0x03	; 3
 c44:	9c 93       	st	X, r25
 c46:	8e 93       	st	-X, r24
 c48:	12 97       	sbiw	r26, 0x02	; 2
 c4a:	e0 e0       	ldi	r30, 0x00	; 0
 c4c:	f0 e0       	ldi	r31, 0x00	; 0
 c4e:	8a 81       	ldd	r24, Y+2	; 0x02
 c50:	9b 81       	ldd	r25, Y+3	; 0x03
 c52:	00 97       	sbiw	r24, 0x00	; 0
 c54:	19 f0       	breq	.+6      	; 0xc5c <free+0xe4>
 c56:	fe 01       	movw	r30, r28
 c58:	ec 01       	movw	r28, r24
 c5a:	f9 cf       	rjmp	.-14     	; 0xc4e <free+0xd6>
 c5c:	ce 01       	movw	r24, r28
 c5e:	02 96       	adiw	r24, 0x02	; 2
 c60:	28 81       	ld	r18, Y
 c62:	39 81       	ldd	r19, Y+1	; 0x01
 c64:	82 0f       	add	r24, r18
 c66:	93 1f       	adc	r25, r19
 c68:	20 91 70 01 	lds	r18, 0x0170
 c6c:	30 91 71 01 	lds	r19, 0x0171
 c70:	28 17       	cp	r18, r24
 c72:	39 07       	cpc	r19, r25
 c74:	69 f4       	brne	.+26     	; 0xc90 <free+0x118>
 c76:	30 97       	sbiw	r30, 0x00	; 0
 c78:	29 f4       	brne	.+10     	; 0xc84 <free+0x10c>
 c7a:	10 92 73 01 	sts	0x0173, r1
 c7e:	10 92 72 01 	sts	0x0172, r1
 c82:	02 c0       	rjmp	.+4      	; 0xc88 <free+0x110>
 c84:	13 82       	std	Z+3, r1	; 0x03
 c86:	12 82       	std	Z+2, r1	; 0x02
 c88:	d0 93 71 01 	sts	0x0171, r29
 c8c:	c0 93 70 01 	sts	0x0170, r28
 c90:	df 91       	pop	r29
 c92:	cf 91       	pop	r28
 c94:	08 95       	ret

00000c96 <_exit>:
 c96:	f8 94       	cli

00000c98 <__stop_program>:
 c98:	ff cf       	rjmp	.-2      	; 0xc98 <__stop_program>
